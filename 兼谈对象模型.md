# 兼谈对象模型

## 1.导读

泛型编程（Generic Programming）和面向对象编程（Object-Oriented Programming）虽然属于不同的思维，但它们正是 C++ 的技术主线，所以本课程也讨论 template（模板）。

深入探索面向对象之继承关系（inheritance）所形成的对象模型（Object Model），包括隐藏于底层的 this 指针，vptr（虚指针），vtbl（虚表），virtual mechanism（虚机制），以及虚函数（virtual functions）造成的 polymorphism（多态）效果。

## 2.转换函数

```c++
class Fraction
{
public:
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    operator double() const {
        return (double)(m_numerator / m_denominator);
    }

private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
double d = 4+f;  // 调用operator double()将f转为0.6
```

## 3.非显式单参数构造函数

```c++
class Fraction
{
public:
    // 非显式单参数构造函数
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {
        // 这里需要实现两个分数相加的逻辑
        // 例如，返回一个新的 Fraction 对象，其分子和分母是相加后的结果
        return Fraction(...);
    }
private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
Fraction d2 = f + 4;  // 这里会调用非显式单参数构造函数将4转换为Fraction对象(也就是Fraction(4,1))，然后调用operator+。
```

## 4.转换函数与非显式单参数构造函数

```c++
class 分数  // Fraction
{
public:
    // 构造函数
    分数(int num, int den=1)  // Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }  // : 分子(num), 分母(den) { }

    // 类型转换运算符，将分数转换为 double 类型
    operator double() const {  // operator double() const
        return (double)(m_numerator / m_denominator);  // 返回 (double)(分子 / 分母);
    }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {  // Fraction operator+(const Fraction& f) {
        return Fraction(......);  // return Fraction(......);
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);  // Fraction f(3,5);
Fraction d2 = f + 4;  // [错误] 模糊不清，因为存在转换函数和单参数构造函数
```

## 5.显式单参数构造函数

```c++
class Fraction
{
public:
    explicit Fraction(int num, int den=1)  // 显式单参数构造函数
        : m_numerator(num), m_denominator(den) { }

    operator double() const {  // 类型转换运算符，将 Fraction 对象转换为 double 类型
        return (double)(m_numerator / m_denominator);
    }

    Fraction operator+(const Fraction& f) {  // 加法运算符重载
        return Fraction(......);  // 这里需要实现两个分数相加的逻辑
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};
Fraction f(3,5);
//Fraction d2 = f + 4;  // 这里会出现错误，因为从 double 到 Fraction 的转换不是隐式的
Fraction d2 = f + Fraction(4);  // 显式创建 Fraction 对象
```

## 6.`vector<bool>函数的实现`（代理转换函数）

```c++
template<class Alloc>
class vector<bool, Alloc>
{
public:
    typedef __bit_reference reference;

protected:
    reference operator[](size_type n) {
        return *(begin() + difference_type(n));
    }

    // ... 其他成员和函数
};

struct __bit_reference {
    unsigned int* p;
    unsigned int mask;

public:
    operator bool() const {
        return !(*p & mask);
    }

    // ... 可能还有其他重载运算符或成员函数
};
```

**`reference operator[](size_type n)`**: 这是重载的`operator[]`，用于通过索引`n`访问`vector<bool>`中的元素。它返回一个`__bit_reference`类型的对象，而不是直接返回`bool`值。这是因为`std::vector<bool>`使用位存储布尔值，需要一个特殊的代理来处理。

**`begin() + difference_type(n)`**:

- `begin()`返回一个指向`std::vector<bool>`开始位置的迭代器。
- `difference_type(n)`将`n`转换为适合迭代器的类型（`difference_type`是`std::vector`的内部类型，表示两个迭代器之间的差值）。这里，我们通过加法运算来根据索引`n`定位到对应的元素。

**`return *(begin() + difference_type(n));`**: 通过解引用迭代器`begin() + difference_type(n)`，我们得到的是该位置的`__bit_reference`对象。这个对象实际上是对`bool`值的代理，通过它可以获取或修改存储在位中的布尔值。

**`operator bool()`**: 这是一个类型转换运算符，它允许`__bit_reference`对象隐式转换为`bool`类型。这样，在使用`__bit_reference`时，可以像使用普通布尔值一样进行判断。

**`!(*p & mask)`**: 这行代码执行了一个位运算：

- `*p`解引用`p`指针，得到指向的`unsigned int`的值。
- `*p & mask`通过与运算符（`&`）和掩码`mask`结合，从`unsigned int`中提取出目标布尔值的位。
- `!(*p & mask)`取反操作，如果该位为`1`，则返回`false`，如果该位为`0`，则返回`true`。这使得我们能够正确地将位转换为布尔值。

## 7.智能指针

```c++
template<class T>
class shared_ptr
{
public:
    T& operator*() const { return *px; }
    T* operator->() const { return px; }
    shared_ptr(T* p) : px(p) { }

private:
    T* px;
    long* pn;
    // ... other members and methods ...
};

struct Foo
{
    void method(void) { }
    // ... other members and methods ...
};

int main() {
    shared_ptr<Foo> sp(new Foo);
    Foo f(*sp);
    sp->method();
    px->method(); // This line is likely a mistake and should be 'sp->method();'
    return 0;
}
```

注意：->有特殊的行为，作用在一个变量上后它会继续作用下去，也就是链式调用。

## 8.迭代器

迭代器是C++标准库中用于遍历容器元素的一种工具。它提供了一种统一的方式来访问容器中的元素，而不需要了解容器的内部实现细节。

```c++
template<class T, class Ref, class Ptr>
struct __list_iterator {
    typedef __list_iterator<T, Ref, Ptr> self;
    typedef Ptr pointer;
    typedef Ref reference;
    typedef __list_node<T>* link_type;
    link_type node;

    bool operator==(const self& x) const { return node == x.node; }
    bool operator!=(const self& x) const { return node != x.node; }

    reference operator*() const { return (*node).data; }
    pointer operator->() const { return &(operator*()); }

    self& operator++() { node = (link_type)(*node).next; return *this; }
    self operator++(int) { self tmp = *this; ++*this; return tmp; }
    self& operator--() { node = (link_type)(*node).prev; return *this; }
    self operator--(int) { self tmp = *this; --*this; return tmp; }
};

template <class T>
struct __list_node {
    void* prev;
    void* next;
    T data;
};
```

在 C++ 中，`operator` 是一种特殊的成员函数，用于定义当使用运算符（例如 `+`、`-`、`[]`、`==` 等）时，自定义类或结构体的行为。通过重载运算符，可以让用户定义类的实例如何与其他对象进行交互，甚至与内置类型进行交互。运算符重载可以让你的类像内置类型一样方便地进行操作。

## 9.仿函数

仿函数是定义了 `operator()` 的类，它们可以像函数一样被调用。仿函数常用于提供自定义操作，尤其是在算法中作为回调函数使用。

```c++
template <class T>
struct identity {
    const T& operator()(const T& x) const { return x; }
};

template <class Pair>
struct select1st {
    const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }
};

template <class Pair>
struct select2nd {
    const typename Pair::second_type& operator()(const Pair& x) const { return x.second; }
};

template <class T1, class T2>
struct pair {
    T1 first;
    T2 second;
    pair() : first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b) : first(a), second(b) {}
    // ... other members and methods ...
};
```

1. **`typename`**：关键字，用于告诉编译器 `Pair::first_type` 是一个类型。在模板编程中，当从另一个类型（在这里是 `Pair`）中引用成员类型时，需要使用 `typename` 来避免歧义，因为编译器可能无法立即识别它是一个类型。
2. **`Pair::first_type`**：表示 `Pair` 类型中定义的第一个成员的类型。`Pair` 是一个模板类，它有两个成员变量 `first` 和 `second`，分别对应于 `first_type` 和 `second_type`。这里 `first_type` 是 `Pair` 模板参数中第一个参数的类型。

```c++
template <class T>
struct identity : public unary_function<T, T> {
    const T& operator()(const T& x) const { return x; }
};

template <class Pair>
struct select1st : public unary_function<Pair, typename Pair::first_type> {
    const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }
};

template <class Pair>
struct select2nd : public unary_function<Pair, typename Pair::second_type> {
    const typename Pair::second_type& operator()(const Pair& x) const { return x.second; }
};
```

1. **`identity` 仿函数**：
   - `template <class T>`：定义了一个模板结构体 `identity`，它接受一个类型参数 `T`。
   - `struct identity : public unary_function<T, T>`：`identity` 结构体继承自 `unary_function`，这是一个标准库中的模板类，用于定义一元仿函数的接口。这里，`unary_function` 的模板参数 `T, T` 表示输入和输出类型都是 `T`。
   - `const T& operator()(const T& x) const { return x; }`：重载了函数调用运算符 `operator()`，使得 `identity` 对象可以像函数一样被调用。这个函数简单地返回传入的参数 `x`。
2. **`select1st` 仿函数**：
   - `template <class Pair>`：定义了一个模板结构体 `select1st`，它接受一个类型参数 `Pair`，这里 `Pair` 应该是一个包含 `first` 和 `second` 成员的类型，如 `std::pair`。
   - `struct select1st : public unary_function<Pair, typename Pair::first_type>`：`select1st` 结构体继承自 `unary_function`，其模板参数 `Pair, typename Pair::first_type` 表示输入类型是 `Pair`，输出类型是 `Pair` 的 `first` 成员的类型。
   - `const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }`：重载了函数调用运算符，返回 `Pair` 对象 `x` 的 `first` 成员。
3. **`select2nd` 仿函数**：
   - 类似于 `select1st`，但返回的是 `Pair` 对象的 `second` 成员。

**它们的基类**

```c++
template <class Arg, class Result>
struct unary_function {
    typedef Arg argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};
```

它们是 C++ 标准库中用于支持仿函数的基类：

1. `unary_function`：这是一个一元仿函数的基类，它有两个类型定义：
   - `argument_type`：表示仿函数接受的参数类型。
   - `result_type`：表示仿函数的返回类型。
2. `binary_function`：这是一个二元仿函数的基类，它有三个类型定义：
   - `first_argument_type`：表示仿函数接受的第一个参数类型。
   - `second_argument_type`：表示仿函数接受的第二个参数类型。
   - `result_type`：表示仿函数的返回类型。

## 10.namespace 经验谈

```c++
using namespace std;

// ... 其他代码 ...

namespace jj01
{
    void test_member_template()
    {
        // ... 成员模板函数的实现 ...
    }
} // namespace

// ... 其他代码 ...

#include <iostream>
#include <list>

namespace jj02
{
    template<typename T>
    using Lst = list<T, allocator<T>>;

    void test_template_template_param()
    {
        // ... 模板模板参数函数的实现 ...
    }
} // namespace

int main(int argc, char** argv)
{
    jj01::test_member_template();
    jj02::test_template_template_param();
}
```

在C++中，命名空间（Namespace）是一种将程序中的实体（如变量、函数、类等）组织在一起的机制，以避免命名冲突。命名冲突可能发生在多个库或程序模块中使用了相同的名称时。以下是对命名空间的详细讲解：

1. **定义命名空间**：
   - 使用 `namespace` 关键字后跟命名空间的名称来定义一个命名空间。例如，`namespace jj01` 和 `namespace jj02` 分别定义了两个不同的命名空间。
2. **命名空间的作用**：
   - 命名空间允许你为程序中的实体定义一个唯一的前缀。这样，即使两个不同的库定义了相同名称的函数或变量，它们也可以通过命名空间前缀来区分。
3. **作用域限定符**：
   - 当你在命名空间内部定义了函数或对象后，你可以通过命名空间名称和作用域解析运算符 `::` 来引用它们。例如，`jj01::test_member_template` 表示调用 `jj01` 命名空间中的 `test_member_template` 函数。
4. **使用命名空间**：
   - 要在程序中使用命名空间中的实体，你可以通过两种方式：
     - **完全限定名**：直接使用命名空间名称和作用域解析运算符，如 `jj01::test_member_template()`。
     - **using 声明**：在文件或函数作用域内使用 `using` 关键字来引入命名空间中的特定实体或整个命名空间。例如，`using jj01::test_member_template;` 或 `using namespace jj01;`。
5. **using 命名空间**：
   - 使用 `using namespace` 可以简化代码，避免每次都要写完整的命名空间前缀。但是，过度使用 `using namespace` 可能会导致命名冲突，因此建议谨慎使用。
6. **命名空间的嵌套**：
   - 命名空间可以嵌套，即一个命名空间内部可以定义另一个命名空间。这为组织大型项目提供了更多的灵活性。
7. **命名空间的别名**：
   - C++11 引入了命名空间别名（Namespace Alias），允许你为命名空间定义一个简短的别名。例如，`namespace jj = jj01;` 之后，你可以使用 `jj::test_member_template()` 来代替 `jj01::test_member_template()`。

## 11.类模板

在设计类的时候，把类型抽出来进行指定。

```c++
template<typename T>
class complex
{
public:
    complex (T r = 0, T i = 0)
        : re(r), im(i)
    {
    }
    complex& operator += (const complex&);
    T real() const { return re; }
    T imag() const { return im; }
private:
    T re, im;

    friend complex& __doapl (complex*, const complex&);
};

{
    complex<double> c1(2.5,1.5);
    complex<int> c2(2,6);
    ...
}
```

## 12.函数模板

```c++
class stone
{
public:
    stone(int w, int h, int we)
        : _w(w), _h(h), _weight(we)
    {
    }
    bool operator< (const stone& rhs) const
    {
        return _weight < rhs._weight;
    }
private:
    int _w, _h, _weight;
};
```

```c++
template <class T>
inline
const T& min(const T& a, const T& b)
{
    return b < a ? b : a;
}
```

实参推导的结果，T 为 stone，于是调用 stone::operator<

```c++
stone r1(2,3), r2(3,3), r3;
r3 = min(r1, r2);
```

编译器会对 function template 进行实参推导 (argument deduction)

## 13.成员模板

在模板里面再套用模板。

```c++
template <class T1, class T2>
struct pair {
    typedef T1 first_type;
    typedef T2 second_type;

    T1 first;
    T2 second;

    pair()
        : first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b)
        : first(a), second(b) {}
	//成员模板
    template <class U1, class U2>
    pair(const pair<U1, U2>& p)
        : first(p.first), second(p.second) {}
    //
};
```

**具体示例**

- 把一个由“鲫鱼”和“麻雀”构成的 pair，放进（拷贝到）一个由“鱼类”和“鸟类”构成的 pair 中，可以吗？反之，可以吗？
- Base1 鱼类   <-- Derived1 鲫鱼
- Base2 鸟类   <-- Derived2 麻雀

```c++
class Base1 { };
class Derived1: public Base1 { };
class Base2 { };
class Derived2: public Base2 { };

pair<Derived1, Derived2> p;

pair<Base1, Base2> p2(p);

pair<Base1, Base2> p2(pair<Derived1, Derived2>());
```

在C++中，如果`Derived1`是`Base1`的派生类，`Derived2`是`Base2`的派生类，那么可以创建一个`pair<Derived1, Derived2>`类型的变量`p`。然后，可以创建一个`pair<Base1, Base2>`类型的变量`p2`，并将`p`作为参数传递给`p2`的构造函数。这是可能的，因为派生类的对象可以被当作其基类的对象使用，这是多态性的一部分。

反之，如果尝试将一个`pair<Base1, Base2>`类型的对象直接赋值给一个`pair<Derived1, Derived2>`类型的对象，这是不允许的，因为基类对象不能被隐式转换为派生类对象，这违反了继承的规则。

```C++
template <class T1, class T2>
struct pair {
    T1 first;
    T2 second;
    pair(): first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b): first(a), second(b) {}
    template <class U1, class U2>
    pair(const pair<U1, U2>& p): first(p.first), second(p.second) {}
};
```

在代码中，`pair`模板定义了一个构造函数，它接受另一个`pair`对象作为参数，并将`first`和`second`成员分别初始化为传入`pair`对象的`first`和`second`成员。这允许不同类型但兼容的`pair`对象之间进行拷贝构造。

**示例二**

```c++
template<typename _Tp>
class shared_ptr: public _shared_ptr<_Tp>
{
public:
    template<typename _Tp1>
    explicit shared_ptr(_Tp1* _p)
    : _shared_ptr<_Tp>(_p) {}
};

class Base1 { };
class Derived1: public Base1 { };

Base1* ptr = new Derived1; // up-cast
shared_ptr<Base1> sptr(new Derived1); // 模拟 up-cast
```

这段代码展示了C++中的继承和类型转换（up-cast）。`shared_ptr`是一个模板类，它继承自一个私有的基类`_shared_ptr`。`shared_ptr`提供了一个构造函数，允许从派生类的指针（`_Tp1*`）构造一个`shared_ptr`对象，这是通过调用基类的构造函数实现的。

在类继承结构中，`Derived1`是从`Base1`派生的。创建`Base1`类型的指针`ptr`并让它指向`Derived1`类型的对象是一种up-cast，即从派生类向基类的转换，这是安全且隐式允许的。

`shared_ptr<Base1> sptr(new Derived1);`这行代码模拟了up-cast，即使用`shared_ptr`模板创建一个智能指针，它管理着一个`Derived1`类型的对象，但是以`Base1`类型的方式。这是C++中多态性的一个应用，允许以基类类型来处理派生类对象。

## 14.模板特化

```c++
//泛化
template <class Key>
struct hash { };
//特化
template<>
struct hash<char> {
    size_t operator() (char x) const { return x; }
};

template<>
struct hash<int> {
    size_t operator() (int x) const { return x; }
};

template<>
struct hash<long> {
    size_t operator() (long x) const { return x; }
};

cout << hash<long>()(1000);
```

这段代码展示了C++中的模板特化（template specialization）。模板特化允许为模板类或模板函数定义特定的实现，这些实现针对特定的类型参数。

1. `hash`是一个模板结构体，它定义了一个函数调用运算符`operator()`，该运算符接受一个类型为`Key`的参数，并返回一个`size_t`类型的值。
2. 对于`char`、`int`和`long`类型，`hash`模板被特化。这意味着为这些特定类型提供了`hash`结构体的专门实现。在这些特化中，`operator()`函数简单地返回传入的参数值。
3. `hash<long>()(1000)`这行代码创建了一个`long`类型的`hash`特化实例，并调用其`operator()`函数，传入参数`1000`。由于`hash<long>`的特化实现，这将直接返回`1000`。

这种模板特化常用于容器类如`unordered_map`或`unordered_set`，它们需要一个哈希函数来计算元素的哈希值。通过特化，可以为不同的键类型提供合适的哈希函数实现。

泛化版本：

全泛化，接受任意类型。

特化版本：

偏特化，针对特定类型进行特化。