# 兼谈对象模型

## 1.导读

泛型编程（Generic Programming）和面向对象编程（Object-Oriented Programming）虽然属于不同的思维，但它们正是 C++ 的技术主线，所以本课程也讨论 template（模板）。

深入探索面向对象之继承关系（inheritance）所形成的对象模型（Object Model），包括隐藏于底层的 this 指针，vptr（虚指针），vtbl（虚表），virtual mechanism（虚机制），以及虚函数（virtual functions）造成的 polymorphism（多态）效果。

## 2.转换函数

```c++
class Fraction
{
public:
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    operator double() const {
        return (double)(m_numerator / m_denominator);
    }

private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
double d = 4+f;  // 调用operator double()将f转为0.6
```

## 3.非显式单参数构造函数

```c++
class Fraction
{
public:
    // 非显式单参数构造函数
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {
        // 这里需要实现两个分数相加的逻辑
        // 例如，返回一个新的 Fraction 对象，其分子和分母是相加后的结果
        return Fraction(...);
    }
private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
Fraction d2 = f + 4;  // 这里会调用非显式单参数构造函数将4转换为Fraction对象(也就是Fraction(4,1))，然后调用operator+。
```

## 4.转换函数与非显式单参数构造函数

```c++
class 分数  // Fraction
{
public:
    // 构造函数
    分数(int num, int den=1)  // Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }  // : 分子(num), 分母(den) { }

    // 类型转换运算符，将分数转换为 double 类型
    operator double() const {  // operator double() const
        return (double)(m_numerator / m_denominator);  // 返回 (double)(分子 / 分母);
    }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {  // Fraction operator+(const Fraction& f) {
        return Fraction(......);  // return Fraction(......);
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);  // Fraction f(3,5);
Fraction d2 = f + 4;  // [错误] 模糊不清，因为存在转换函数和单参数构造函数
```

## 5.显式单参数构造函数

```c++
class Fraction
{
public:
    explicit Fraction(int num, int den=1)  // 显式单参数构造函数
        : m_numerator(num), m_denominator(den) { }

    operator double() const {  // 类型转换运算符，将 Fraction 对象转换为 double 类型
        return (double)(m_numerator / m_denominator);
    }

    Fraction operator+(const Fraction& f) {  // 加法运算符重载
        return Fraction(......);  // 这里需要实现两个分数相加的逻辑
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};
Fraction f(3,5);
//Fraction d2 = f + 4;  // 这里会出现错误，因为从 double 到 Fraction 的转换不是隐式的
Fraction d2 = f + Fraction(4);  // 显式创建 Fraction 对象
```

## 6.`vector<bool>函数的实现`（代理转换函数）

```c++
template<class Alloc>
class vector<bool, Alloc>
{
public:
    typedef __bit_reference reference;

protected:
    reference operator[](size_type n) {
        return *(begin() + difference_type(n));
    }

    // ... 其他成员和函数
};

struct __bit_reference {
    unsigned int* p;
    unsigned int mask;

public:
    operator bool() const {
        return !(*p & mask);
    }

    // ... 可能还有其他重载运算符或成员函数
};
```

**`reference operator[](size_type n)`**: 这是重载的`operator[]`，用于通过索引`n`访问`vector<bool>`中的元素。它返回一个`__bit_reference`类型的对象，而不是直接返回`bool`值。这是因为`std::vector<bool>`使用位存储布尔值，需要一个特殊的代理来处理。

**`begin() + difference_type(n)`**:

- `begin()`返回一个指向`std::vector<bool>`开始位置的迭代器。
- `difference_type(n)`将`n`转换为适合迭代器的类型（`difference_type`是`std::vector`的内部类型，表示两个迭代器之间的差值）。这里，我们通过加法运算来根据索引`n`定位到对应的元素。

**`return *(begin() + difference_type(n));`**: 通过解引用迭代器`begin() + difference_type(n)`，我们得到的是该位置的`__bit_reference`对象。这个对象实际上是对`bool`值的代理，通过它可以获取或修改存储在位中的布尔值。

**`operator bool()`**: 这是一个类型转换运算符，它允许`__bit_reference`对象隐式转换为`bool`类型。这样，在使用`__bit_reference`时，可以像使用普通布尔值一样进行判断。

**`!(*p & mask)`**: 这行代码执行了一个位运算：

- `*p`解引用`p`指针，得到指向的`unsigned int`的值。
- `*p & mask`通过与运算符（`&`）和掩码`mask`结合，从`unsigned int`中提取出目标布尔值的位。
- `!(*p & mask)`取反操作，如果该位为`1`，则返回`false`，如果该位为`0`，则返回`true`。这使得我们能够正确地将位转换为布尔值。

## 7.智能指针

```c++
template<class T>
class shared_ptr
{
public:
    T& operator*() const { return *px; }
    T* operator->() const { return px; }
    shared_ptr(T* p) : px(p) { }

private:
    T* px;
    long* pn;
    // ... other members and methods ...
};

struct Foo
{
    void method(void) { }
    // ... other members and methods ...
};

int main() {
    shared_ptr<Foo> sp(new Foo);
    Foo f(*sp);
    sp->method();
    px->method(); // This line is likely a mistake and should be 'sp->method();'
    return 0;
}
```

注意：->有特殊的行为，作用在一个变量上后它会继续作用下去，也就是链式调用。

## 8.迭代器

迭代器是C++标准库中用于遍历容器元素的一种工具。它提供了一种统一的方式来访问容器中的元素，而不需要了解容器的内部实现细节。

```c++
template<class T, class Ref, class Ptr>
struct __list_iterator {
    typedef __list_iterator<T, Ref, Ptr> self;
    typedef Ptr pointer;
    typedef Ref reference;
    typedef __list_node<T>* link_type;
    link_type node;

    bool operator==(const self& x) const { return node == x.node; }
    bool operator!=(const self& x) const { return node != x.node; }

    reference operator*() const { return (*node).data; }
    pointer operator->() const { return &(operator*()); }

    self& operator++() { node = (link_type)(*node).next; return *this; }
    self operator++(int) { self tmp = *this; ++*this; return tmp; }
    self& operator--() { node = (link_type)(*node).prev; return *this; }
    self operator--(int) { self tmp = *this; --*this; return tmp; }
};

template <class T>
struct __list_node {
    void* prev;
    void* next;
    T data;
};
```

在 C++ 中，`operator` 是一种特殊的成员函数，用于定义当使用运算符（例如 `+`、`-`、`[]`、`==` 等）时，自定义类或结构体的行为。通过重载运算符，可以让用户定义类的实例如何与其他对象进行交互，甚至与内置类型进行交互。运算符重载可以让你的类像内置类型一样方便地进行操作。

## 9.仿函数

仿函数是定义了 `operator()` 的类，它们可以像函数一样被调用。仿函数常用于提供自定义操作，尤其是在算法中作为回调函数使用。

```c++
template <class T>
struct identity {
    const T& operator()(const T& x) const { return x; }
};

template <class Pair>
struct select1st {
    const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }
};

template <class Pair>
struct select2nd {
    const typename Pair::second_type& operator()(const Pair& x) const { return x.second; }
};

template <class T1, class T2>
struct pair {
    T1 first;
    T2 second;
    pair() : first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b) : first(a), second(b) {}
    // ... other members and methods ...
};
```

1. **`typename`**：关键字，用于告诉编译器 `Pair::first_type` 是一个类型。在模板编程中，当从另一个类型（在这里是 `Pair`）中引用成员类型时，需要使用 `typename` 来避免歧义，因为编译器可能无法立即识别它是一个类型。
2. **`Pair::first_type`**：表示 `Pair` 类型中定义的第一个成员的类型。`Pair` 是一个模板类，它有两个成员变量 `first` 和 `second`，分别对应于 `first_type` 和 `second_type`。这里 `first_type` 是 `Pair` 模板参数中第一个参数的类型。

```c++
template <class T>
struct identity : public unary_function<T, T> {
    const T& operator()(const T& x) const { return x; }
};

template <class Pair>
struct select1st : public unary_function<Pair, typename Pair::first_type> {
    const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }
};

template <class Pair>
struct select2nd : public unary_function<Pair, typename Pair::second_type> {
    const typename Pair::second_type& operator()(const Pair& x) const { return x.second; }
};
```

1. **`identity` 仿函数**：
   - `template <class T>`：定义了一个模板结构体 `identity`，它接受一个类型参数 `T`。
   - `struct identity : public unary_function<T, T>`：`identity` 结构体继承自 `unary_function`，这是一个标准库中的模板类，用于定义一元仿函数的接口。这里，`unary_function` 的模板参数 `T, T` 表示输入和输出类型都是 `T`。
   - `const T& operator()(const T& x) const { return x; }`：重载了函数调用运算符 `operator()`，使得 `identity` 对象可以像函数一样被调用。这个函数简单地返回传入的参数 `x`。
2. **`select1st` 仿函数**：
   - `template <class Pair>`：定义了一个模板结构体 `select1st`，它接受一个类型参数 `Pair`，这里 `Pair` 应该是一个包含 `first` 和 `second` 成员的类型，如 `std::pair`。
   - `struct select1st : public unary_function<Pair, typename Pair::first_type>`：`select1st` 结构体继承自 `unary_function`，其模板参数 `Pair, typename Pair::first_type` 表示输入类型是 `Pair`，输出类型是 `Pair` 的 `first` 成员的类型。
   - `const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }`：重载了函数调用运算符，返回 `Pair` 对象 `x` 的 `first` 成员。
3. **`select2nd` 仿函数**：
   - 类似于 `select1st`，但返回的是 `Pair` 对象的 `second` 成员。

**它们的基类**

```c++
template <class Arg, class Result>
struct unary_function {
    typedef Arg argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};
```

它们是 C++ 标准库中用于支持仿函数的基类：

1. `unary_function`：这是一个一元仿函数的基类，它有两个类型定义：
   - `argument_type`：表示仿函数接受的参数类型。
   - `result_type`：表示仿函数的返回类型。
2. `binary_function`：这是一个二元仿函数的基类，它有三个类型定义：
   - `first_argument_type`：表示仿函数接受的第一个参数类型。
   - `second_argument_type`：表示仿函数接受的第二个参数类型。
   - `result_type`：表示仿函数的返回类型。

## 10.namespace 经验谈

```c++
using namespace std;

// ... 其他代码 ...

namespace jj01
{
    void test_member_template()
    {
        // ... 成员模板函数的实现 ...
    }
} // namespace

// ... 其他代码 ...

#include <iostream>
#include <list>

namespace jj02
{
    template<typename T>
    using Lst = list<T, allocator<T>>;

    void test_template_template_param()
    {
        // ... 模板模板参数函数的实现 ...
    }
} // namespace

int main(int argc, char** argv)
{
    jj01::test_member_template();
    jj02::test_template_template_param();
}
```

在C++中，命名空间（Namespace）是一种将程序中的实体（如变量、函数、类等）组织在一起的机制，以避免命名冲突。命名冲突可能发生在多个库或程序模块中使用了相同的名称时。以下是对命名空间的详细讲解：

1. **定义命名空间**：
   - 使用 `namespace` 关键字后跟命名空间的名称来定义一个命名空间。例如，`namespace jj01` 和 `namespace jj02` 分别定义了两个不同的命名空间。
2. **命名空间的作用**：
   - 命名空间允许你为程序中的实体定义一个唯一的前缀。这样，即使两个不同的库定义了相同名称的函数或变量，它们也可以通过命名空间前缀来区分。
3. **作用域限定符**：
   - 当你在命名空间内部定义了函数或对象后，你可以通过命名空间名称和作用域解析运算符 `::` 来引用它们。例如，`jj01::test_member_template` 表示调用 `jj01` 命名空间中的 `test_member_template` 函数。
4. **使用命名空间**：
   - 要在程序中使用命名空间中的实体，你可以通过两种方式：
     - **完全限定名**：直接使用命名空间名称和作用域解析运算符，如 `jj01::test_member_template()`。
     - **using 声明**：在文件或函数作用域内使用 `using` 关键字来引入命名空间中的特定实体或整个命名空间。例如，`using jj01::test_member_template;` 或 `using namespace jj01;`。
5. **using 命名空间**：
   - 使用 `using namespace` 可以简化代码，避免每次都要写完整的命名空间前缀。但是，过度使用 `using namespace` 可能会导致命名冲突，因此建议谨慎使用。
6. **命名空间的嵌套**：
   - 命名空间可以嵌套，即一个命名空间内部可以定义另一个命名空间。这为组织大型项目提供了更多的灵活性。
7. **命名空间的别名**：
   - C++11 引入了命名空间别名（Namespace Alias），允许你为命名空间定义一个简短的别名。例如，`namespace jj = jj01;` 之后，你可以使用 `jj::test_member_template()` 来代替 `jj01::test_member_template()`。

## 11.类模板

在设计类的时候，把类型抽出来进行指定。

```c++
template<typename T>
class complex
{
public:
    complex (T r = 0, T i = 0)
        : re(r), im(i)
    {
    }
    complex& operator += (const complex&);
    T real() const { return re; }
    T imag() const { return im; }
private:
    T re, im;

    friend complex& __doapl (complex*, const complex&);
};

{
    complex<double> c1(2.5,1.5);
    complex<int> c2(2,6);
    ...
}
```

## 12.函数模板

```c++
class stone
{
public:
    stone(int w, int h, int we)
        : _w(w), _h(h), _weight(we)
    {
    }
    bool operator< (const stone& rhs) const
    {
        return _weight < rhs._weight;
    }
private:
    int _w, _h, _weight;
};
```

```c++
template <class T>
inline
const T& min(const T& a, const T& b)
{
    return b < a ? b : a;
}
```

实参推导的结果，T 为 stone，于是调用 stone::operator<

```c++
stone r1(2,3), r2(3,3), r3;
r3 = min(r1, r2);
```

编译器会对 function template 进行实参推导 (argument deduction)

## 13.成员模板

在模板里面再套用模板。

```c++
template <class T1, class T2>
struct pair {
    typedef T1 first_type;
    typedef T2 second_type;

    T1 first;
    T2 second;

    pair()
        : first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b)
        : first(a), second(b) {}
	//成员模板
    template <class U1, class U2>
    pair(const pair<U1, U2>& p)
        : first(p.first), second(p.second) {}
    //
};
```

**具体示例**

- 把一个由“鲫鱼”和“麻雀”构成的 pair，放进（拷贝到）一个由“鱼类”和“鸟类”构成的 pair 中，可以吗？反之，可以吗？
- Base1 鱼类   <-- Derived1 鲫鱼
- Base2 鸟类   <-- Derived2 麻雀

```c++
class Base1 { };
class Derived1: public Base1 { };
class Base2 { };
class Derived2: public Base2 { };

pair<Derived1, Derived2> p;

pair<Base1, Base2> p2(p);

pair<Base1, Base2> p2(pair<Derived1, Derived2>());
```

在C++中，如果`Derived1`是`Base1`的派生类，`Derived2`是`Base2`的派生类，那么可以创建一个`pair<Derived1, Derived2>`类型的变量`p`。然后，可以创建一个`pair<Base1, Base2>`类型的变量`p2`，并将`p`作为参数传递给`p2`的构造函数。这是可能的，因为派生类的对象可以被当作其基类的对象使用，这是多态性的一部分。

反之，如果尝试将一个`pair<Base1, Base2>`类型的对象直接赋值给一个`pair<Derived1, Derived2>`类型的对象，这是不允许的，因为基类对象不能被隐式转换为派生类对象，这违反了继承的规则。

```C++
template <class T1, class T2>
struct pair {
    T1 first;
    T2 second;
    pair(): first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b): first(a), second(b) {}
    template <class U1, class U2>
    pair(const pair<U1, U2>& p): first(p.first), second(p.second) {}
};
```

在代码中，`pair`模板定义了一个构造函数，它接受另一个`pair`对象作为参数，并将`first`和`second`成员分别初始化为传入`pair`对象的`first`和`second`成员。这允许不同类型但兼容的`pair`对象之间进行拷贝构造。

**示例二**

```c++
template<typename _Tp>
class shared_ptr: public _shared_ptr<_Tp>
{
public:
    template<typename _Tp1>
    explicit shared_ptr(_Tp1* _p)
    : _shared_ptr<_Tp>(_p) {}
};

class Base1 { };
class Derived1: public Base1 { };

Base1* ptr = new Derived1; // up-cast
shared_ptr<Base1> sptr(new Derived1); // 模拟 up-cast
```

这段代码展示了C++中的继承和类型转换（up-cast）。`shared_ptr`是一个模板类，它继承自一个私有的基类`_shared_ptr`。`shared_ptr`提供了一个构造函数，允许从派生类的指针（`_Tp1*`）构造一个`shared_ptr`对象，这是通过调用基类的构造函数实现的。

在类继承结构中，`Derived1`是从`Base1`派生的。创建`Base1`类型的指针`ptr`并让它指向`Derived1`类型的对象是一种up-cast，即从派生类向基类的转换，这是安全且隐式允许的。

`shared_ptr<Base1> sptr(new Derived1);`这行代码模拟了up-cast，即使用`shared_ptr`模板创建一个智能指针，它管理着一个`Derived1`类型的对象，但是以`Base1`类型的方式。这是C++中多态性的一个应用，允许以基类类型来处理派生类对象。

## 14.模板特化

```c++
//泛化
template <class Key>
struct hash { };
//特化
template<>
struct hash<char> {
    size_t operator() (char x) const { return x; }
};

template<>
struct hash<int> {
    size_t operator() (int x) const { return x; }
};

template<>
struct hash<long> {
    size_t operator() (long x) const { return x; }
};

cout << hash<long>()(1000);
```

这段代码展示了C++中的模板特化（template specialization）。模板特化允许为模板类或模板函数定义特定的实现，这些实现针对特定的类型参数。

1. `hash`是一个模板结构体，它定义了一个函数调用运算符`operator()`，该运算符接受一个类型为`Key`的参数，并返回一个`size_t`类型的值。
2. 对于`char`、`int`和`long`类型，`hash`模板被特化。这意味着为这些特定类型提供了`hash`结构体的专门实现。在这些特化中，`operator()`函数简单地返回传入的参数值。
3. `hash<long>()(1000)`这行代码创建了一个`long`类型的`hash`特化实例，并调用其`operator()`函数，传入参数`1000`。由于`hash<long>`的特化实现，这将直接返回`1000`。

这种模板特化常用于容器类如`unordered_map`或`unordered_set`，它们需要一个哈希函数来计算元素的哈希值。通过特化，可以为不同的键类型提供合适的哈希函数实现。

泛化版本：

全泛化，接受任意类型。

特化版本：

偏特化，针对特定类型进行特化。

## 15.模板偏特化

### 1.个数上的偏

```c++
template<typename T, typename Alloc=......>
class vector
{
    ...
};

template<typename Alloc=......>
class vector<bool, Alloc>
{
    ...
};
```

这段代码展示了C++中模板类`vector`的基本定义，以及一个针对`bool`类型的特化版本。在第一个定义中，`T`是一个类型参数，`Alloc`是一个分配器类型参数，它有一个默认值。在第二个定义中，`vector`被特化为`bool`类型，并且`Alloc`仍然可以被指定。这种特化允许为`bool`类型的`vector`提供特定的实现细节，这在某些情况下可以提高性能或满足特定的需求.

### 2.范围上的偏

```c++
template <typename T>
class C
{
    ...
};

template <typename T>
class C<T*>
{
    ...
};

template <typename U>
class C<U*>
{
    ...
};

C<string> obj1;
C<string*> obj2;
```

这段代码展示了C++中的模板类`C`，以及两个特化版本：一个针对类型`T*`的特化，另一个针对类型`U*`的特化。这意味着，当你创建一个`C`类的实例时，如果传递的是指针类型，编译器会根据指针的类型来选择相应的特化版本。

## 16.模板模板参数

```c++
template<typename T,
         template <typename T> class Container>
class XCls
{
private:
    Container<T> c;
public:
    .....
};

template<typename T>
using Lst = list<T, allocator<T>>;

XCls<string, list> myList1; //错误
XCls<string, Lst> myList2;
```

这段代码定义了一个模板类`XCls`，它有两个模板参数：`T`是类模板的类型参数，`Container`是一个模板类类型参数，它本身也接受一个类型参数。在`XCls`类中，有一个私有成员`c`，它是`Container<T>`类型的实例。

接着，定义了一个模板别名`List`，它是一个`list`容器，带有类型`T`和分配器`allocator<T>`。

最后，创建了两个`XCls`类型的对象`myList1`和`myList2`，它们都使用了`string`作为类型参数，但`myList1`直接使用了`list`作为容器，而`myList2`使用了定义的别名`Lst`。

代码有一个错误标记在`XCls<string, list> myList1;`这一行，这可能是因为`list`没有被正确地识别为模板类。在C++中，`std::list`是一个模板类，所以正确的用法应该是`std::list`，如果`list`是在`std`命名空间中的话。如果`list`是自定义的模板类，那么它应该在相应的命名空间中或者已经被`using`声明引入当前作用域。

```c++
template<typename T,
         template <typename T> class SmartPtr>
class XCls
{
private:
    SmartPtr<T> sp; // 使用SmartPtr模板类来管理T类型的对象
public:
    XCls() : sp(new T) { } // 构造函数，初始化sp为T类型的新对象
};
```

1. `XCls<string, shared_ptr> p1;` 使用`std::shared_ptr`来管理`string`类型的对象。
2. `XCls<double, unique_ptr> p2;` 使用`std::unique_ptr`来管理`double`类型的对象。
3. `XCls<int, weak_ptr> p3;` 这里有一个错误，因为`std::weak_ptr`不能直接用来管理对象，它需要与`std::shared_ptr`一起使用。
4. `XCls<long, auto_ptr> p4;` 这里也有一个错误，因为`std::auto_ptr`在C++11中已经被弃用，并且在C++17中被移除。它不应该用于现代C++代码中。

**注意：这不是模板模板参数**

```c++
template <class T, class Sequence = deque<T>>
class stack {
    friend bool operator==(const stack&, const stack&);
    friend bool operator<(const stack&, const stack&);

protected:
    Sequence c; // 底层容器
    ...
};

stack<int> s1;
stack<int, list<int>> s2;//这个后面的list<int>已经绑定了，所以不是模板模板参数。
```

## 17.关于C++标准库

容器<---迭代器，算法<---仿函数

容器就是存储的数据结构。

算法就是存放的写好的算法。

## 18.三个主题

### 1.数量不定的模板参数(来自C++11)

```c++
void print() {}

template <typename T, typename... Types>
void print(const T& firstArg, const Types&... args) {
    cout << firstArg << endl;
    print(args...);
}
print(7.5,"hello",bitset<16>(377),42);
result:
{
    7.5
    hello
    0000000101111001
    42
}
```

```text
...就是一个所谓的包
用于 template parameters, 就是 template parameters pack (模板参数包)
用于 function parameter types, 就是 function parameter types pack (函数参数类型包)
用于 function parameters, 就是 function parameters pack (函数参数包)
```

在可变模板中，`sizeof...(args)`可以得到产生参数的数量。

### 2.auto(来自C++11)

```c++
list<string> c;
...
list<string>::iterator ite;
ite = find(c.begin(), c.end(), target);

list<string> c;
...
auto ite = find(c.begin(), c.end(), target);

list<string> c;
...
auto ite;//错误
ite = find(c.begin(), c.end(), target);
```

第三个代码块是错误的，因为`auto`关键字需要在初始化时就确定类型，而不能单独声明`auto`类型的变量然后再赋值

### 3.ranged-base for(来自C++11)

```c++\
for (decl : coll) {
    statement
}

for (int i : { 2, 3, 5, 7, 9, 13, 17, 19 }) {
    cout << i << endl;
}

vector<double> vec;
...
for (auto elem : vec) {
    cout << elem << endl;
}

for (auto& elem : vec) {
    elem *= 3;
}
```

范围基`for`循环（range-based for loop）的使用。这种循环允许你遍历容器中的每个元素，而无需显式地使用迭代器。

## 19.引用

```c++
int x=0;
int* p = &x;
int& r = x; //r代表x。现在r，x都是0
int x2=5;
r = x2;  //r现在不能重新代表其他物件。现在 r, x 都是5
int& r2=r; //现在r2是5(r2代表r;亦相当于代表x)
```

- 注意：1, sizeof(r) == sizeof(x)

   		   2, &x == &r;

- r is a reference to x
- p is a pointer to x
- object 和其 reference 的大小相同，地址也相同（全都是假象）
- Java 里头所有变量都是 reference

```c++
typedef struct Stag { int a, b, c, d; } S;

int main() {
    double x = 0;
    double* p = &x; // p指向x，p的值是x的地址
    double& r = x;  // r代表x，现在r, x都是0

    cout << sizeof(x) << endl;       // 输出x的大小，通常是8字节
    cout << sizeof(p) << endl;      // 输出p的大小，通常是4字节（指针大小）
    cout << sizeof(r) << endl;      // 输出r的大小，也是8字节，与x相同
    cout << p << endl;              // 输出p的地址，例如0065FDFC
    cout << *p << endl;             // 输出p指向的值，即x的值，这里是0
    cout << x << endl;              // 直接输出x的值，也是0
    cout << r << endl;              // 输出r的值，同样是0
    cout << &x << endl;             // 输出x的地址，与p的地址相同，例如0065FDFC
    cout << &r << endl;             // 输出r的地址，也与x的地址相同，例如0065FDFC

    S s;
    S* rs = &s;
    cout << sizeof(s) << endl;      // 输出结构体S的大小，通常是16字节（假设int为4字节）
    cout << sizeof(rs) << endl;     // 输出rs的大小，也是4字节（指针大小）
    cout << &s << endl;             // 输出s的地址，例如0065FDE8
    cout << &rs << endl;            // 输出rs的地址，与s的地址相同，例如0065FDE8
}
```

强调了对象和引用的大小相同，地址也相同，这些都是假象。在C++中，引用是一个别名，它并不占用额外的存储空间，它的大小和地址与它所引用的对象相同。这在内存管理上是一个重要的概念，因为它允许引用像变量一样使用，同时保持与原始对象的直接联系。

```c++
void func1(Cls* pobj) { pobj->xxx(); }
void func2(Cls obj) { obj.xxx(); }
void func3(Cls& obj) { obj.xxx(); }

Cls obj;
func1(&obj);//接口不同，困扰
func2(obj);//调用端接口相同，很好
func3(obj);//调用端接口相同，很好
//以下被视为“same signature”（所以二者不能同时存在）：
// 函数签名相同，导致二义性
double imag(const double& im) { ... }
double imag(const double im) { ... }//Ambiguity（二义性）
```

- reference通常不用于声明变量，而用于参数类型（parameters type）和返回类型（return type）的描述。
- Q: const是不是函数签名的一部分？
- A: （根据C++的规则，const不是函数签名的一部分。）

## 20.复合&继承关系下的构造和祈构

### 1.继承关系下的构造和祈构

**类的结构**

```cpp
class Base {
    virtual ~Base() = 0;  // 基类析构函数必须是virtual
    // ...
};

class Derived : public Base {
    ~Derived();
    // ...
};
```

**构造顺序（由内而外）**

构造过程是从基类开始，然后到派生类：
```cpp
Derived::Derived(...) : Base() {  // 首先调用Base的构造函数
    // 然后执行Derived自己的构造代码
}
```

**析构顺序（由外而内）**

析构过程与构造相反，从派生类开始，然后是基类：
```cpp
Derived::~Derived() {
    // 首先执行Derived的析构代码
    // Base的析构函数会自动在最后调用
}  // ~Base()被自动调用
```

**重要注意事项**

- **基类析构函数必须是virtual**：如果基类的析构函数不是virtual，将会导致未定义行为（undefined behavior）
- **内存布局**：派生类对象中包含了一个完整的基类部分（base part）

**对象结构示意图**

```
+------------------+
|   Derived对象    |
|  +------------+ |
|  |  Base部分   | |
|  |            | |
|  +------------+ |
|                 |
+------------------+
```

这种构造和析构的顺序设计确保了：
1. 构造时基类先准备好，派生类才能安全地构造
2. 析构时派生类先清理自己的资源，基类的资源才被清理

类似于建房子：地基（基类）要先建好才能建上层（派生类），拆除时则要从上层开始拆起。

### 2.复合关系下的构造和祈构

**类的关系图**

```cpp
class Container {
private:
    Component component;  // 复合关系：Container包含Component
};
```

**对象结构**

```
+------------------+
|  Container对象   |
|  +------------+ |
|  | Component  | |
|  |    部分    | |
|  +------------+ |
+------------------+
```

**构造顺序（由内而外）**

构造过程是从成员对象开始，然后到容器类：
```cpp
Container::Container(...) : Component() {  // 首先调用Component的构造函数
    // 然后执行Container自己的构造代码
}
```

**析构顺序（由外而内**）

析构过程与构造相反，从容器类开始，然后是成员对象：
```cpp
Container::~Container() {
    // 首先执行Container的析构代码
    // Component的析构函数会自动在最后调用
}  // ~Component()被自动调用
```

**重点说明**

1. 构造顺序：
   - 先构造成员对象（Component）
   - 后执行容器类（Container）的构造代码

2. 析构顺序：
   - 先执行容器类（Container）的析构代码
   - 后析构成员对象（Component）

这种构造和析构的顺序确保了：
- 构造时成员对象先准备好，容器类才能安全地使用它们
- 析构时容器类先清理自己的资源，再清理成员对象

类似于组装电脑：先要有各个组件（内存、硬盘等），才能组装成完整的电脑；拆解时则要先断电，再拆除各个组件。

### 3.复合和继承关系下的构造和祈构

**类的关系**

```cpp
class Base { ... };

class Derived : public Base {  // 继承关系
private:
    Component component;      // 复合关系
};
```

**对象结构**

```
+------------------+
|   Derived对象    |
|  +------------+ |
|  |  Base部分   | |
|  +------------+ |
|  +------------+ |
|  | Component  | |
|  |    部分    | |
|  +------------+ |
+------------------+
```

**构造顺序（由内而外）**

构造过程的顺序：
```cpp
Derived::Derived(...) : Base(), Component() {
    // 1. 调用Base的构造函数
    // 2. 调用Component的构造函数
    // 3. 执行Derived自己的构造代码
}
```

**析构顺序（由外而内）**

析构过程的顺序：
```cpp
Derived::~Derived() {
    // 1. 执行Derived的析构代码
    // 2. 调用Component的析构函数
    // 3. 调用Base的析构函数
}
```

**重点说明**

1. 构造顺序（从内到外）：
   - 首先构造基类（Base）
   - 然后构造成员对象（Component）
   - 最后执行派生类（Derived）的构造代码

2. 析构顺序（从外到内）：
   - 首先执行派生类（Derived）的析构代码
   - 然后析构成员对象（Component）
   - 最后析构基类（Base）

这种顺序确保了：
- 构造时基础部分先准备好，复合对象次之，最后才是派生类的初始化
- 析构时按照与构造相反的顺序进行清理，确保资源的安全释放

就像建造一栋带家具的房子：
1. 构造：先打地基（Base），再安装家具（Component），最后完成装修（Derived）
2. 拆除：先清空房子（Derived），再搬出家具（Component），最后拆除地基（Base）

## 21.虚指针和虚表

1. 类的继承关系：
```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func2();
private:
    int m_data3;
};

class C : public B {
public:
    virtual void vfunc1();
    void func2();
private:
    int m_data1;
    int m_data4;
};
```

每个对象通过vptr指向其对应的虚函数表

相同的虚函数（如未被重写的vfunc2）在不同的vtbl中指向相同的地址(0x401F10)

被重写的虚函数（如vfunc1）在每个子类的vtbl中有不同的地址

但是普通函数都是单独有自己的内存空间。

2. 虚函数表（vtbl）和虚函数指针（vptr）的内存布局：

- 每个对象都包含一个vptr（虚函数指针），指向该类的虚函数表
- 虚函数表包含类的虚函数地址
- 内存地址示例：
  - A对象地址：0x409004
  - B对象地址：0x409014
  - C对象地址：0x409024
  - A的vtbl地址：0x401ED0
  - B的vtbl地址：0x401F80
  - C的vtbl地址：0x401FF0

3. 关键概念：
- virtual关键字用于声明虚函数
- 虚函数实现了运行时多态
- 派生类可以重写基类的虚函数
- 对象内存布局包含：
  - 虚函数指针(vptr)
  - 类的成员变量
  - 继承的成员变量

4. 访问虚函数的方式：
```cpp
(* (p->vptr)[n])(p);
// 或
(* p->vptr[n])(p);
```
其中：
- p是对象指针
- n是虚函数在虚函数表中的索引
- 这是虚函数调用的底层实现机制

## 22.关于this

1. 代码结构：
```cpp
// 基类
class CDocument {
public:
    void OnFileOpen() {
        // ...
        Serialize();  // 调用虚函数
        // ...
    }
    virtual void Serialize() = 0;  // 纯虚函数
};

// 派生类
class CMyDoc : public CDocument {
public:
    virtual void Serialize() {
        // 具体实现
    }
};

// 主函数
int main() {
    CMyDoc myDoc;
    myDoc.OnFileOpen();  // 会调用 CMyDoc::Serialize()
}
```

2. 关键知识点：
- 模板方法设计模式（Template Method Pattern）的实现
  - 基类定义算法骨架（OnFileOpen）
  - 派生类实现具体步骤（Serialize）

- 动态绑定机制
  - this指针指向实际对象
  - 通过虚函数表查找正确的函数版本
  - `(*(this->vptr)[n])(this)` 是虚函数调用的底层实现

- 框架设计思想
  - 框架（CDocument）定义主要流程
  - 应用程序（CMyDoc）提供具体实现
  - 通过虚函数实现扩展点

3. 设计要点：
- 基类中的公共方法（OnFileOpen）定义了算法的基本步骤
- 将变化的部分（Serialize）声明为虚函数
- 子类通过重写虚函数来自定义行为
- this指针在运行时确保调用正确版本的函数

## 23.关于Dynamic Building

1. 类的继承关系：

```cpp
class A {
    virtual void vfunc1();
    // ...其他成员
};

class B : public A {
    virtual void vfunc1();
    // ...其他成员
};

class C : public B {
    // ...
};
```

2. 代码示例和对应的汇编：

```cpp
// 代码段
B b;                          // 汇编: lea ecx,[b]
                             // call @ILT+535(B::B)
A a = (A)b;                  // 汇编: lea eax,[b]
                             // push eax
                             // lea ecx,[ebp-114h]
                             // call @ILT+830(A::A)
a.vfunc1();                  // 静态绑定，调用A::vfunc1()
                             // lea ecx,[a]
                             // call @ILT+420(A::vfunc1)

A* pa = new B;
pa->vfunc1();               // 动态绑定，运行时决定调用B::vfunc1()

pa = &b;                    // up cast
pa->vfunc1();              // 动态绑定，调用B::vfunc1()
```

3. 关键知识点：

- `a.vfunc1()`是静态绑定，直接调用A类的vfunc1
- `pa->vfunc1()`是动态绑定，通过虚函数表查找实际对象类型的vfunc1
- 汇编代码显示了对象构造和函数调用的底层实现
- lea指令用于加载有效地址
- call指令用于函数调用

4. 重要区别：

- 静态绑定：编译时确定函数地址
- 动态绑定：运行时通过虚函数表查找函数地址

## 24.简单谈论

### 1.谈谈const

代码结构：
```cpp
class complex {  // 复数类
public:  // 公有部分
    complex(double r = 0, double i = 0)  // 构造函数，带默认参数
        : re(r), im(i) 
    { }
    
    complex& operator+=(const complex&);  // 重载+=运算符
    double real() const { return re; }    // 获取实部的常量成员函数
    double imag() const { return im; }    // 获取虚部的常量成员函数

private:  // 私有部分
    double re, im;  // 实部和虚部
    
    friend complex& __doapl(complex*, const complex&);  // 友元函数
};

// 两个使用示例的对比：
{
    complex c1(2,1);         // 普通对象
    cout << c1.real();       // 调用real()
    cout << c1.imag();       // 调用imag()
}

{
    const complex c1(2,1);   // 常量对象
    cout << c1.real();       // 仍然可以调用real()
    cout << c1.imag();       // 仍然可以调用imag()
}
```

1. **常量成员函数 (const member functions)**: 
   - `real()` 和 `imag()` 方法被声明为 `const` 限定符
   - 这表示它们保证不会修改对象的状态
   - 它们可以被 const 和非 const 对象调用

2. **成员函数实现**:
   - 简单的访问器方法，返回私有成员变量
   - 构造函数使用初始化列表
   - 私有数据成员 `re` 和 `im` 存储复数的组件

3. **使用对比**:
   - 示例展示了两种情况：
     1. 使用普通（非 const）对象调用方法
     2. 使用 const 对象调用方法
   - 两种情况都能正常工作，因为这些方法被声明为 const

4. **类设计**:
   - 遵循封装原则，使用私有数据成员
   - 公共接口提供对数据的受控访问
   - 包含运算符重载和友元函数声明
   - 构造函数的默认参数允许灵活的对象创建

关于 C++ const 的重要知识点：

1. **成员函数的 const 和 non-const 版本共存规则**：
   - const 对象只能调用 const 版本的成员函数
   - non-const 对象只能调用 non-const 版本的成员函数

2. **调用权限表格说明**：

| 函数类型                                   | const 对象<br>(数据成员不可变动) | non-const 对象<br>(数据成员可变动) |
| ------------------------------------------ | -------------------------------- | ---------------------------------- |
| const 成员函数<br>(保证不更改数据成员)     | ✓ 允许                           | ✓ 允许                             |
| non-const 成员函数<br>(不保证数据成员不变) | ✗ 不允许                         | ✓ 允许                             |

3. **重要示例解析**：
```cpp
const String str("hello world");
str.print();
```
这个例子说明了一个重要设计原则：
- 如果在设计初期没有将 `print()` 声明为 const 成员函数
- 那么通过 const 对象调用 non-const 成员函数时会导致编译错误
- 这种情况不符合开发者的预期

4. **转换规则**：
- non-const 成员函数可以调用 const 成员函数
- 反过来不允许（const 成员函数不能调用 non-const 成员函数）
- 违反这个规则会导致编译错误：
  ```
  (VC) error C2662: cannot convert 'this' pointer from 'const class X' to 'class X &'. Conversion loses qualifiers
  ```

5. **设计建议**：
- 如果成员函数不会修改对象状态，应该将其声明为 const
- 这样可以保证函数在 const 和 non-const 对象上都能使用
- 增加代码的灵活性和可用性

这些规则和限制的存在是为了确保代码的安全性和一致性，防止通过 const 对象意外修改数据成员。

关于 C++ STL basic_string 类模板中的 COW (Copy On Write) 机制的知识点：

1. **基本定义**：
```cpp
class template std::basic_string<...> {
    // 两个重要的成员函数
    charT operator[] (size_type pos) const    // 常量版本
    { ... /* 不必考虑 COW */ }
    
    reference operator[] (size_type pos)       // 非常量版本
    { ... /* 必须考虑 COW */ }
};
```

2. **COW (Copy On Write) 写时复制机制**：
   - COW 是一种优化技术，用于减少不必要的内存复制
   - 多个 string 对象可以共享同一块内存，直到需要修改时才进行复制

3. **两种操作符重载的区别**：

   - **常量版本 (const)**:
     - 返回 `charT`（字符类型）
     - 只读访问，不会修改字符串内容
     - 不需要考虑 COW 机制
     - 直接返回字符即可

   - **非常量版本**:
     - 返回 `reference`（引用类型）
     - 可能会修改字符串内容
     - 必须考虑 COW 机制
     - 在返回引用前可能需要复制数据

4. **为什么需要区分**：
   - const 版本确保不会修改内容，所以无需考虑 COW
   - 非 const 版本可能会修改内容，必须确保修改不会影响其他共享该内存的对象

5. **性能影响**：
   - const 版本性能较好，因为不需要 COW 检查
   - 非 const 版本可能需要额外的检查和可能的内存复制操作

这是 STL 中的一个重要优化设计，通过 COW 机制和 const/non-const 重载来平衡内存使用和性能。

## 25.关于new，delete

关于 C++ 中 new 和 delete 操作的重要知识点：

1. **new 操作的过程**：
```cpp
String* ps = new String("Hello");
```
new 操作分为两步：
- 先分配 memory（内存空间）
- 再调用 ctor（构造函数）

内部实现大致为：
```cpp
void* mem = operator new( /* 分配内存 */ );
ps = static_cast<String*>(mem);
ps->String::String("Hello"); // 调用构造函数
```

2. **delete 操作的过程**：
```cpp
delete ps;
```
delete 操作也分为两步：
- 先调用 dtor（析构函数）
- 再释放 memory（内存空间）

内部实现大致为：
```cpp
String::~String(ps);    // 调用析构函数
operator delete(ps);    // 释放内存
```

3. **类的内存结构**：
```cpp
class String {
public:
    String(...) { ... }
    ~String() { ... }
private:
    char* m_data;  // 指向实际字符串数据的指针
};
```

4. **数组的 new 和 delete**：
```cpp
String* p = new String[3];  // 创建对象数组
delete[] p;                 // 删除对象数组，必须使用 delete[]
```
- 使用 new[] 时要配对使用 delete[]
- delete[] 会正确调用每个对象的析构函数

5. **内存管理注意点**：
- new 和 delete 必须配对使用
- 使用 new[] 分配的内存必须使用 delete[] 释放
- delete 会自动调用析构函数清理资源
- 内存分配和构造函数调用是分开的两个步骤
- 析构函数调用和内存释放也是分开的两个步骤

这些概念对于理解 C++ 的内存管理和资源管理非常重要，可以帮助我们避免内存泄漏和其他常见的内存相关问题。

## 26.new,delete的重载

### 1.重载::operator new,::operator delete,::operator new[],::operator delete[]

1. **基础内存分配释放函数**：
```cpp
void* myAlloc(size_t size) {
    return malloc(size);
}

void myFree(void* ptr) {
    return free(ptr);
}
```

2. **运算符重载的实现**：
```cpp
// 单个对象的 new 运算符重载
inline void* operator new(size_t size) {
    cout << "jjhou global new()\n";
    return myAlloc(size);
}

// 对象数组的 new 运算符重载
inline void* operator new[](size_t size) {
    cout << "jjhou global new[]()\n";
    return myAlloc(size);
}

// 单个对象的 delete 运算符重载
inline void operator delete(void* ptr) {
    cout << "jjhou global delete()\n";
    myFree(ptr);
}

// 对象数组的 delete 运算符重载
inline void operator delete[](void* ptr) {
    cout << "jjhou global delete[]()\n";
    myFree(ptr);
}
```

3. **重要知识点**：
   - 这些运算符重载函数不能被声明在某个命名空间内
   - 所有函数都使用 inline 修饰，提高执行效率
   - 重载函数封装了底层的 malloc/free 调用
   - 添加了调试输出语句，便于跟踪内存操作

4. **使用场景**：
   - 单个对象：使用 new/delete
   - 对象数组：使用 new[]/delete[]
   - 必须配对使用，否则可能导致内存泄漏或未定义行为

5. **注意事项**：
   - 图中标注"小心，这影响无远弗届"说明这些全局运算符重载会影响整个程序的内存分配行为
   - new 和 new[] 都返回 void* 指针
   - delete 和 delete[] 都接收 void* 指针参数
   - 运算符重载使我们能够监控或自定义内存分配行为

6. **设计意图**：
   - 提供内存分配的跟踪机制
   - 可以自定义内存分配策略
   - 便于调试内存相关问题
   - 可以实现特殊的内存管理需求

这样的实现允许我们监控和控制程序的内存分配行为，对于调试内存问题和优化内存使用非常有帮助。

### 2.重载member operator new/delete

成员运算符 new/delete 的代码和知识点：

1. **类的定义**：
```cpp
class Foo {
public:
    void* operator new(size_t);            // per-class allocator
    void operator delete(void*, size_t);    // optional
    // ...
};
```

2. **对象创建过程**：
```cpp
Foo* p = new Foo;  // 表面代码

// 实际执行的步骤：
try {
    void* mem = operator new(sizeof(Foo));    // 步骤1：分配内存
    p = static_cast<Foo*>(mem);              // 类型转换
    p->Foo::Foo();                           // 步骤2：调用构造函数
}
```

3. **对象销毁过程**：
```cpp
delete p;  // 表面代码

// 实际执行的步骤：
p->~Foo();                  // 步骤1：调用析构函数
operator delete(p);         // 步骤2：释放内存
```

4. **重要知识点**：

- **Per-class allocator（类专属分配器）**：
  - 通过重载成员 operator new/delete 实现
  - 允许类自定义其内存分配策略
  - 这些操作符是静态成员函数（即使没有显式声明 static）

- **Optional parameter（可选参数）**：
  - operator delete 的 size_t 参数是可选的
  - 该参数提供被删除对象的大小信息
  - 可以用于优化内存管理

- **异常安全**：
  - 使用 try 块确保内存分配和构造过程的安全
  - 如果构造函数抛出异常，确保正确释放已分配的内存

5. **使用场景**：
- 需要特殊内存管理策略的类
- 需要跟踪对象内存使用的场合
- 实现内存池或其他优化策略
- 需要自定义内存对齐的情况

6. **注意事项**：
- 重载这些运算符会影响类的所有对象的内存分配行为
- 需要确保与全局 operator new/delete 的语义一致
- 实现时要考虑异常安全
- 要正确处理内存对齐问题

这种机制让类能够完全控制其对象的内存分配和释放行为，是 C++ 中重要的自定义内存管理机制。

### 3.重载member operator new[]/delete[]

关于数组版本的 member operator new[]/delete[] 的代码和知识点：

1. **类的定义**：
```cpp
class Foo {
public:
    // 数组版本的 per-class allocator
    void* operator new[](size_t);
    void operator delete[](void*, size_t);    // optional
    // ...
};
```

2. **数组对象创建过程**：
```cpp
Foo* p = new Foo[N];  // 表面代码

// 实际执行的步骤：
try {
    void* mem = operator new(sizeof(Foo) * N);  // 步骤1：分配内存
    p = static_cast<Foo*>(mem);                 // 类型转换
    for(int i = 0; i < N; i++) {               // 步骤2：调用N次构造函数
        p[i].Foo::Foo();
    }
}
```

3. **数组对象销毁过程**：
```cpp
delete[] p;  // 表面代码

// 实际执行的步骤：
for(int i = 0; i < N; i++) {     // 步骤1：调用N次析构函数
    p[i].~Foo();
}
operator delete[](p);            // 步骤2：释放内存
```

4. **重要知识点**：

- **数组版本的特点**：
  - 使用 `operator new[]` 和 `operator delete[]`
  - 需要处理多个对象的内存分配和释放
  - 构造和析构需要循环调用 N 次

- **内存管理**：
  - 分配的内存大小是 sizeof(Foo) * N
  - 可能需要额外空间存储数组大小信息
  - 必须使用对应的 delete[] 来释放内存

- **Per-class allocator 特性**：
  - 允许类自定义数组对象的内存分配策略
  - 可以实现特殊的数组内存布局
  - size_t 参数在 delete[] 中是可选的

5. **注意事项**：
- new[] 必须和 delete[] 配对使用
- 需要正确处理数组大小的记录和获取
- 要考虑对象数组的对齐要求
- 实现需要考虑异常安全性

6. **与单对象版本的区别**：
- 内存分配大小不同（需要考虑数组大小）
- 构造和析构函数的调用次数不同
- 可能需要额外的簿记信息（bookkeeping）
- 错误处理更复杂（需要处理部分构造的情况）

这个机制为数组对象提供了自定义内存管理的能力，使得类可以完全控制其数组对象的内存分配和释放行为。

## 27.示例

```c++
class Foo {
public:
    int _id;
    long _data;
    string _str;
    
public:
    // 构造函数
    Foo() : _id(0) { cout << "default ctor. this=" << this << " id=" << _id; }
    Foo(int i) : _id(i) { cout << "ctor. this=" << this << " id=" << id; }
    
    // 析构函数
    virtual ~Foo() { cout << "dtor. this=" << this << " id=" << _id; }
    
    // 重载 new/delete 操作符
    static void* operator new(size_t size);
    static void operator delete(void* pdead, size_t size);
    static void* operator new[](size_t size);
    static void operator delete[](void* pdead, size_t size);
};

// new 操作符实现
void* Foo::operator new(size_t size) {
    Foo* p = (Foo*)malloc(size);
    cout << "...";
    return p;
}

// delete 操作符实现
void Foo::operator delete(void* pdead, size_t size) {
    cout << "...";
    free(pdead);
}

// new[] 操作符实现
void* Foo::operator new[](size_t size) {
    Foo* p = (Foo*)malloc(size);
    cout << "...";
    return p;
}

// delete[] 操作符实现
void Foo::operator delete[](void* pdead, size_t size) {
    cout << "...";
    free(pdead);
}
```

笔记要点：

1. 内存管理：
   - 示例展示了如何自定义类的内存分配和释放机制
   - 通过重载 new/delete 操作符来控制对象的内存管理
   - 同时处理了单个对象和数组对象的情况
2. 操作符重载：
   - `operator new`: 处理单个对象的内存分配
   - `operator delete`: 处理单个对象的内存释放
   - `operator new[]`: 处理对象数组的内存分配
   - `operator delete[]`: 处理对象数组的内存释放
3. 实现细节：
   - 所有重载的操作符都被声明为 static
   - 内部使用 malloc/free 进行实际的内存操作
   - 每个操作都包含了大小参数 size_t size
   - 实现中包含了输出语句用于跟踪内存操作

1. 显示类内部的操作：
```cpp
Foo* pf = new Foo;  // 使用类成员operator new
delete pf;          // 使用类成员operator delete
```

2. 显示全局作用域的操作：
```cpp
Foo* pf = ::new Foo;    // 使用全局operator new
::delete pf;            // 使用全局operator delete
```

关键点说明：
- 当类没有定义自己的成员operator new/delete时，会自动使用全局的版本
- 使用`::`前缀可以强制使用全局版本，即使类有自己的实现
- 全局版本的声明：
  ```cpp
  void* ::operator new(size_t);
  void ::operator delete(void*);
  ```

使用场景：
1. 当你想要绕过类的自定义内存管理，使用系统默认的内存分配方式时，可以使用全局版本
2. 在某些特殊情况下需要确保使用标准内存分配时，可以通过`::`显式指定使用全局版本

注意：使用全局版本会绕过类的自定义内存管理策略，要谨慎使用，确保了解可能带来的影响。

## 28.重载new(),delete()

"我们可以重载 class member operator new()，写出多个版本，前提是每一版本的声明都必须有独特的参数列，其中第一参数必须是 size_t，其余参数以 new 所指定的 placement arguments 为初值。出现于 new (.....) 小括号内的便是所谓 placement arguments。"

```c++
// Placement new 的使用
Foo* pf = new(300, 'c') Foo;

// 这可能被称为 placement operator delete
```

Placement new 特点：

- 必须有 size_t 作为第一个参数
- 可以有额外的自定义参数
- 这些参数通过 new 操作符的括号传入

Placement delete特点：

- 可以有多个重载版本
- 不会被普通 delete 调用
- 仅在构造函数抛出异常时被调用
- 用于释放构造失败的对象内存

"我们也可以重载class member operator delete()，写出多个版本。它们总不会被 delete调用。只有当new所调用的ctor抛出 exception，才会调用这些重载版本的 operator delete()。它可能这样被调用，主要用来归还未能完全创建成功的 object 所占用的 memory。"

**示例：**

```c++
class Foo {
public:
    Foo() { cout << "Foo::Foo()" << endl; }
    Foo(int) { cout << "Foo::Foo(int)" << endl; throw Bad(); }

    // (1) 普通的 operator new 重载
    void* operator new(size_t size) {
        return malloc(size);
    }

    // (2) 标准库提供的 placement new 重载形式
    void* operator new(size_t size, void* start) {
        return start;
    }

    // (3) 自定义的 placement new
    void* operator new(size_t size, long extra) {
        return malloc(size + extra);
    }

    // (4) 另一个自定义的 placement new
    void* operator new(size_t size, long extra, char init) {
        return malloc(size + extra);
    }

    // (5) 错误示例
    void* operator new(long extra, char init) {    // 错误！
        // [Error] 'operator new' takes type 'size_t' as first parameter
        return malloc(extra);
    }
	 // (1) 普通的 operator delete 重载
    void operator delete(void* ptr, size_t size) {
        cout << "operator delete(void*,size_t)" << endl;
    }

    // (2) 对应标准 placement new 的 delete
    void operator delete(void* ptr, void* start) {
        cout << "operator delete(void*,void*)" << endl;
    }

    // (3) 对应自定义 placement new 的 delete
    void operator delete(void* ptr, long extra) {
        cout << "operator delete(void*,long)" << endl;
    }

    // (4) 对应带两个额外参数的 placement new 的 delete
    void operator delete(void* ptr, long extra, char init) {
        cout << "operator delete(void*,long,char)" << endl;
    }

private:
    int m_i;
};
class Bad{};
```

关键点总结：

1. 普通的 operator new：
   - 第一个参数必须是 size_t 类型
   - 用于普通的内存分配
2. 标准 placement new：
   - 接受一个额外的 void* 参数
   - 在指定的内存位置构造对象
   - 直接返回传入的指针
3. 自定义 placement new：
   - 可以添加额外的参数
   - 但第一个参数必须是 size_t
   - 可以根据额外参数调整分配的内存大小
4. 错误示例：
   - 演示了错误的重载方式
   - 第一个参数不是 size_t 类型会导致编译错误

代码中特意抛出异常的目的：

- 通过 `throw Bad();` 来测试 placement operator delete 的调用
- 当构造函数抛出异常时，对应的 placement delete 会被调用来清理内存

**重载delete()的作用**

1. 这些 placement delete 是与之前的 placement new 一一对应的
2. 它们只在构造函数抛出异常时被调用
3. 主要用于释放对应的 placement new 分配的内存
4. 即使 operator delete 没有与 operator new 完全匹配，也不会出现错误
5. 这些重载的目的是处理构造函数抛出的异常情况

注意事项：

- VC6 会发出警告 C4291（没有匹配的 operator delete 时初始化抛出异常）
- 根据输出结果显示，当构造函数抛出异常时，会调用相应的 delete 操作符
- 正常的对象析构不会调用这些 placement delete
- 这是异常处理机制的一部分，用于确保内存正确释放

## 29.basic_string使用new(extra)扩充申请量

```c++
template<class charT, class traits, class Allocator>
class basic_string {
private:
    struct Rep {
        void release() { if (--ref == 0) delete this; }
        inline static void* operator new(size_t s, size_t extra);
        inline static void operator delete(void* ptr);
        inline static Rep* create(size_t extra);
        // ...
    };
    // ...
};

// Rep 的 operator new 实现
template<class charT, class traits, class Allocator>
inline void* basic_string<charT, traits, Allocator>::Rep::
operator new(size_t s, size_t extra) {
    return Allocator::allocate(s + extra * sizeof(charT));
}

// Rep 的 operator delete 实现
template<class charT, class traits, class Allocator>
inline void basic_string<charT, traits, Allocator>::Rep::
operator delete(void* ptr) {
    Allocator::deallocate(ptr, sizeof(Rep) + 
        reinterpret_cast<Rep*>(ptr)->res * sizeof(charT));
}

// Rep 的 create 函数实现
template<class charT, class traits, class Allocator>
inline basic_string<charT, traits, Allocator>::Rep*
basic_string<charT, traits, Allocator>::Rep::create(size_t extra) {
    extra = frob_size(extra + 1);
    Rep* p = new(extra) Rep;
    // ...
    return p;
}
```

关键点分析：

1. 内存结构：
   - basic_string 使用 Rep（表示）结构来管理实际的字符串数据
   - 内存布局包括 Rep 结构和额外的字符串存储空间
2. placement new 的使用：
   - operator new 接受额外的 size_t 参数用于字符串存储空间
   - 分配的内存大小 = Rep 结构大小 + 额外字符存储空间
3. 内存管理：
   - 使用 Allocator 进行实际的内存分配和释放
   - create 函数封装了创建新 Rep 对象的过程
   - 通过 release 函数和引用计数管理内存释放