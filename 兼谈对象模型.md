# 兼谈对象模型

## 1.导读

泛型编程（Generic Programming）和面向对象编程（Object-Oriented Programming）虽然属于不同的思维，但它们正是 C++ 的技术主线，所以本课程也讨论 template（模板）。

深入探索面向对象之继承关系（inheritance）所形成的对象模型（Object Model），包括隐藏于底层的 this 指针，vptr（虚指针），vtbl（虚表），virtual mechanism（虚机制），以及虚函数（virtual functions）造成的 polymorphism（多态）效果。

## 2.转换函数

```c++
class Fraction
{
public:
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    operator double() const {
        return (double)(m_numerator / m_denominator);
    }

private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
double d = 4+f;  // 调用operator double()将f转为0.6
```

## 3.非显式单参数构造函数

```c++
class Fraction
{
public:
    // 非显式单参数构造函数
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {
        // 这里需要实现两个分数相加的逻辑
        // 例如，返回一个新的 Fraction 对象，其分子和分母是相加后的结果
        return Fraction(...);
    }
private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
Fraction d2 = f + 4;  // 这里会调用非显式单参数构造函数将4转换为Fraction对象(也就是Fraction(4,1))，然后调用operator+。
```

## 4.转换函数与非显式单参数构造函数

```c++
class 分数  // Fraction
{
public:
    // 构造函数
    分数(int num, int den=1)  // Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }  // : 分子(num), 分母(den) { }

    // 类型转换运算符，将分数转换为 double 类型
    operator double() const {  // operator double() const
        return (double)(m_numerator / m_denominator);  // 返回 (double)(分子 / 分母);
    }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {  // Fraction operator+(const Fraction& f) {
        return Fraction(......);  // return Fraction(......);
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);  // Fraction f(3,5);
Fraction d2 = f + 4;  // [错误] 模糊不清，因为存在转换函数和单参数构造函数
```

## 5.显式单参数构造函数

```c++
class Fraction
{
public:
    explicit Fraction(int num, int den=1)  // 显式单参数构造函数
        : m_numerator(num), m_denominator(den) { }

    operator double() const {  // 类型转换运算符，将 Fraction 对象转换为 double 类型
        return (double)(m_numerator / m_denominator);
    }

    Fraction operator+(const Fraction& f) {  // 加法运算符重载
        return Fraction(......);  // 这里需要实现两个分数相加的逻辑
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};
Fraction f(3,5);
//Fraction d2 = f + 4;  // 这里会出现错误，因为从 double 到 Fraction 的转换不是隐式的
Fraction d2 = f + Fraction(4);  // 显式创建 Fraction 对象
```

## 6.`vector<bool>函数的实现`（代理转换函数）

```c++
template<class Alloc>
class vector<bool, Alloc>
{
public:
    typedef __bit_reference reference;

protected:
    reference operator[](size_type n) {
        return *(begin() + difference_type(n));
    }

    // ... 其他成员和函数
};

struct __bit_reference {
    unsigned int* p;
    unsigned int mask;

public:
    operator bool() const {
        return !(*p & mask);
    }

    // ... 可能还有其他重载运算符或成员函数
};
```

**`reference operator[](size_type n)`**: 这是重载的`operator[]`，用于通过索引`n`访问`vector<bool>`中的元素。它返回一个`__bit_reference`类型的对象，而不是直接返回`bool`值。这是因为`std::vector<bool>`使用位存储布尔值，需要一个特殊的代理来处理。

**`begin() + difference_type(n)`**:

- `begin()`返回一个指向`std::vector<bool>`开始位置的迭代器。
- `difference_type(n)`将`n`转换为适合迭代器的类型（`difference_type`是`std::vector`的内部类型，表示两个迭代器之间的差值）。这里，我们通过加法运算来根据索引`n`定位到对应的元素。

**`return *(begin() + difference_type(n));`**: 通过解引用迭代器`begin() + difference_type(n)`，我们得到的是该位置的`__bit_reference`对象。这个对象实际上是对`bool`值的代理，通过它可以获取或修改存储在位中的布尔值。

**`operator bool()`**: 这是一个类型转换运算符，它允许`__bit_reference`对象隐式转换为`bool`类型。这样，在使用`__bit_reference`时，可以像使用普通布尔值一样进行判断。

**`!(*p & mask)`**: 这行代码执行了一个位运算：

- `*p`解引用`p`指针，得到指向的`unsigned int`的值。
- `*p & mask`通过与运算符（`&`）和掩码`mask`结合，从`unsigned int`中提取出目标布尔值的位。
- `!(*p & mask)`取反操作，如果该位为`1`，则返回`false`，如果该位为`0`，则返回`true`。这使得我们能够正确地将位转换为布尔值。

## 7.智能指针

```c++
template<class T>
class shared_ptr
{
public:
    T& operator*() const { return *px; }
    T* operator->() const { return px; }
    shared_ptr(T* p) : px(p) { }

private:
    T* px;
    long* pn;
    // ... other members and methods ...
};

struct Foo
{
    void method(void) { }
    // ... other members and methods ...
};

int main() {
    shared_ptr<Foo> sp(new Foo);
    Foo f(*sp);
    sp->method();
    px->method(); // This line is likely a mistake and should be 'sp->method();'
    return 0;
}
```

注意：->有特殊的行为，作用在一个变量上后它会继续作用下去，也就是链式调用。

## 8.迭代器

迭代器是C++标准库中用于遍历容器元素的一种工具。它提供了一种统一的方式来访问容器中的元素，而不需要了解容器的内部实现细节。

```c++
template<class T, class Ref, class Ptr>
struct __list_iterator {
    typedef __list_iterator<T, Ref, Ptr> self;
    typedef Ptr pointer;
    typedef Ref reference;
    typedef __list_node<T>* link_type;
    link_type node;

    bool operator==(const self& x) const { return node == x.node; }
    bool operator!=(const self& x) const { return node != x.node; }

    reference operator*() const { return (*node).data; }
    pointer operator->() const { return &(operator*()); }

    self& operator++() { node = (link_type)(*node).next; return *this; }
    self operator++(int) { self tmp = *this; ++*this; return tmp; }
    self& operator--() { node = (link_type)(*node).prev; return *this; }
    self operator--(int) { self tmp = *this; --*this; return tmp; }
};

template <class T>
struct __list_node {
    void* prev;
    void* next;
    T data;
};
```

## 9.仿函数

仿函数是定义了 `operator()` 的类，它们可以像函数一样被调用。仿函数常用于提供自定义操作，尤其是在算法中作为回调函数使用。

```c++
template <class T>
struct identity {
    const T& operator()(const T& x) const { return x; }
};

template <class Pair>
struct select1st {
    const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }
};

template <class Pair>
struct select2nd {
    const typename Pair::second_type& operator()(const Pair& x) const { return x.second; }
};

template <class T1, class T2>
struct pair {
    T1 first;
    T2 second;
    pair() : first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b) : first(a), second(b) {}
    // ... other members and methods ...
};
```

1. **`typename`**：关键字，用于告诉编译器 `Pair::first_type` 是一个类型。在模板编程中，当从另一个类型（在这里是 `Pair`）中引用成员类型时，需要使用 `typename` 来避免歧义，因为编译器可能无法立即识别它是一个类型。
2. **`Pair::first_type`**：表示 `Pair` 类型中定义的第一个成员的类型。`Pair` 是一个模板类，它有两个成员变量 `first` 和 `second`，分别对应于 `first_type` 和 `second_type`。这里 `first_type` 是 `Pair` 模板参数中第一个参数的类型。

```c++
template <class T>
struct identity : public unary_function<T, T> {
    const T& operator()(const T& x) const { return x; }
};

template <class Pair>
struct select1st : public unary_function<Pair, typename Pair::first_type> {
    const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }
};

template <class Pair>
struct select2nd : public unary_function<Pair, typename Pair::second_type> {
    const typename Pair::second_type& operator()(const Pair& x) const { return x.second; }
};
```

1. **`identity` 仿函数**：
   - `template <class T>`：定义了一个模板结构体 `identity`，它接受一个类型参数 `T`。
   - `struct identity : public unary_function<T, T>`：`identity` 结构体继承自 `unary_function`，这是一个标准库中的模板类，用于定义一元仿函数的接口。这里，`unary_function` 的模板参数 `T, T` 表示输入和输出类型都是 `T`。
   - `const T& operator()(const T& x) const { return x; }`：重载了函数调用运算符 `operator()`，使得 `identity` 对象可以像函数一样被调用。这个函数简单地返回传入的参数 `x`。
2. **`select1st` 仿函数**：
   - `template <class Pair>`：定义了一个模板结构体 `select1st`，它接受一个类型参数 `Pair`，这里 `Pair` 应该是一个包含 `first` 和 `second` 成员的类型，如 `std::pair`。
   - `struct select1st : public unary_function<Pair, typename Pair::first_type>`：`select1st` 结构体继承自 `unary_function`，其模板参数 `Pair, typename Pair::first_type` 表示输入类型是 `Pair`，输出类型是 `Pair` 的 `first` 成员的类型。
   - `const typename Pair::first_type& operator()(const Pair& x) const { return x.first; }`：重载了函数调用运算符，返回 `Pair` 对象 `x` 的 `first` 成员。
3. **`select2nd` 仿函数**：
   - 类似于 `select1st`，但返回的是 `Pair` 对象的 `second` 成员。

**它们的基类**

```c++
template <class Arg, class Result>
struct unary_function {
    typedef Arg argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};
```

它们是 C++ 标准库中用于支持仿函数的基类：

1. `unary_function`：这是一个一元仿函数的基类，它有两个类型定义：
   - `argument_type`：表示仿函数接受的参数类型。
   - `result_type`：表示仿函数的返回类型。
2. `binary_function`：这是一个二元仿函数的基类，它有三个类型定义：
   - `first_argument_type`：表示仿函数接受的第一个参数类型。
   - `second_argument_type`：表示仿函数接受的第二个参数类型。
   - `result_type`：表示仿函数的返回类型。

## 10.namespace 经验谈

```c++
using namespace std;

// ... 其他代码 ...

namespace jj01
{
    void test_member_template()
    {
        // ... 成员模板函数的实现 ...
    }
} // namespace

// ... 其他代码 ...

#include <iostream>
#include <list>

namespace jj02
{
    template<typename T>
    using Lst = list<T, allocator<T>>;

    void test_template_template_param()
    {
        // ... 模板模板参数函数的实现 ...
    }
} // namespace

int main(int argc, char** argv)
{
    jj01::test_member_template();
    jj02::test_template_template_param();
}
```

在C++中，命名空间（Namespace）是一种将程序中的实体（如变量、函数、类等）组织在一起的机制，以避免命名冲突。命名冲突可能发生在多个库或程序模块中使用了相同的名称时。以下是对命名空间的详细讲解：

1. **定义命名空间**：
   - 使用 `namespace` 关键字后跟命名空间的名称来定义一个命名空间。例如，`namespace jj01` 和 `namespace jj02` 分别定义了两个不同的命名空间。
2. **命名空间的作用**：
   - 命名空间允许你为程序中的实体定义一个唯一的前缀。这样，即使两个不同的库定义了相同名称的函数或变量，它们也可以通过命名空间前缀来区分。
3. **作用域限定符**：
   - 当你在命名空间内部定义了函数或对象后，你可以通过命名空间名称和作用域解析运算符 `::` 来引用它们。例如，`jj01::test_member_template` 表示调用 `jj01` 命名空间中的 `test_member_template` 函数。
4. **使用命名空间**：
   - 要在程序中使用命名空间中的实体，你可以通过两种方式：
     - **完全限定名**：直接使用命名空间名称和作用域解析运算符，如 `jj01::test_member_template()`。
     - **using 声明**：在文件或函数作用域内使用 `using` 关键字来引入命名空间中的特定实体或整个命名空间。例如，`using jj01::test_member_template;` 或 `using namespace jj01;`。
5. **using 命名空间**：
   - 使用 `using namespace` 可以简化代码，避免每次都要写完整的命名空间前缀。但是，过度使用 `using namespace` 可能会导致命名冲突，因此建议谨慎使用。
6. **命名空间的嵌套**：
   - 命名空间可以嵌套，即一个命名空间内部可以定义另一个命名空间。这为组织大型项目提供了更多的灵活性。
7. **命名空间的别名**：
   - C++11 引入了命名空间别名（Namespace Alias），允许你为命名空间定义一个简短的别名。例如，`namespace jj = jj01;` 之后，你可以使用 `jj::test_member_template()` 来代替 `jj01::test_member_template()`。