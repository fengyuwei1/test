# 兼谈对象模型

## 1.导读

泛型编程（Generic Programming）和面向对象编程（Object-Oriented Programming）虽然属于不同的思维，但它们正是 C++ 的技术主线，所以本课程也讨论 template（模板）。

深入探索面向对象之继承关系（inheritance）所形成的对象模型（Object Model），包括隐藏于底层的 this 指针，vptr（虚指针），vtbl（虚表），virtual mechanism（虚机制），以及虚函数（virtual functions）造成的 polymorphism（多态）效果。

## 2.转换函数

```c++
class Fraction
{
public:
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    operator double() const {
        return (double)(m_numerator / m_denominator);
    }

private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
double d = 4+f;  // 调用operator double()将f转为0.6
```

## 3.非显式单参数构造函数

```c++
class Fraction
{
public:
    // 非显式单参数构造函数
    Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {
        // 这里需要实现两个分数相加的逻辑
        // 例如，返回一个新的 Fraction 对象，其分子和分母是相加后的结果
        return Fraction(...);
    }
private:
    int m_numerator;    // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);
Fraction d2 = f + 4;  // 这里会调用非显式单参数构造函数将4转换为Fraction对象(也就是Fraction(4,1))，然后调用operator+。
```

## 4.转换函数与非显式单参数构造函数

```c++
class 分数  // Fraction
{
public:
    // 构造函数
    分数(int num, int den=1)  // Fraction(int num, int den=1)
        : m_numerator(num), m_denominator(den) { }  // : 分子(num), 分母(den) { }

    // 类型转换运算符，将分数转换为 double 类型
    operator double() const {  // operator double() const
        return (double)(m_numerator / m_denominator);  // 返回 (double)(分子 / 分母);
    }

    // 加法运算符重载
    Fraction operator+(const Fraction& f) {  // Fraction operator+(const Fraction& f) {
        return Fraction(......);  // return Fraction(......);
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};

Fraction f(3,5);  // Fraction f(3,5);
Fraction d2 = f + 4;  // [错误] 模糊不清，因为存在转换函数和单参数构造函数
```

## 5.显式单参数构造函数

```c++
class Fraction
{
public:
    explicit Fraction(int num, int den=1)  // 显式单参数构造函数
        : m_numerator(num), m_denominator(den) { }

    operator double() const {  // 类型转换运算符，将 Fraction 对象转换为 double 类型
        return (double)(m_numerator / m_denominator);
    }

    Fraction operator+(const Fraction& f) {  // 加法运算符重载
        return Fraction(......);  // 这里需要实现两个分数相加的逻辑
    }

private:
    int m_numerator;  // 分子
    int m_denominator;  // 分母
};
Fraction f(3,5);
//Fraction d2 = f + 4;  // 这里会出现错误，因为从 double 到 Fraction 的转换不是隐式的
Fraction d2 = f + Fraction(4);  // 显式创建 Fraction 对象
```

## 6.`vector<bool>函数的实现`（代理转换函数）

```c++
template<class Alloc>
class vector<bool, Alloc>
{
public:
    typedef __bit_reference reference;

protected:
    reference operator[](size_type n) {
        return *(begin() + difference_type(n));
    }

    // ... 其他成员和函数
};

struct __bit_reference {
    unsigned int* p;
    unsigned int mask;

public:
    operator bool() const {
        return !(*p & mask);
    }

    // ... 可能还有其他重载运算符或成员函数
};
```

**`reference operator[](size_type n)`**: 这是重载的`operator[]`，用于通过索引`n`访问`vector<bool>`中的元素。它返回一个`__bit_reference`类型的对象，而不是直接返回`bool`值。这是因为`std::vector<bool>`使用位存储布尔值，需要一个特殊的代理来处理。

**`begin() + difference_type(n)`**:

- `begin()`返回一个指向`std::vector<bool>`开始位置的迭代器。
- `difference_type(n)`将`n`转换为适合迭代器的类型（`difference_type`是`std::vector`的内部类型，表示两个迭代器之间的差值）。这里，我们通过加法运算来根据索引`n`定位到对应的元素。

**`return *(begin() + difference_type(n));`**: 通过解引用迭代器`begin() + difference_type(n)`，我们得到的是该位置的`__bit_reference`对象。这个对象实际上是对`bool`值的代理，通过它可以获取或修改存储在位中的布尔值。

**`operator bool()`**: 这是一个类型转换运算符，它允许`__bit_reference`对象隐式转换为`bool`类型。这样，在使用`__bit_reference`时，可以像使用普通布尔值一样进行判断。

**`!(*p & mask)`**: 这行代码执行了一个位运算：

- `*p`解引用`p`指针，得到指向的`unsigned int`的值。
- `*p & mask`通过与运算符（`&`）和掩码`mask`结合，从`unsigned int`中提取出目标布尔值的位。
- `!(*p & mask)`取反操作，如果该位为`1`，则返回`false`，如果该位为`0`，则返回`true`。这使得我们能够正确地将位转换为布尔值。