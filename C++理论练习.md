# C++理论练习

## 例题1

在64位系统中，有如下类：

```c++
class C
{
public:
    char a;
    static char b;
    void *p;
    static int *c;
    virtual void func1();
    virtual void func2();
};
```

那么sizeof（C）的数值是（）

A.9

B.17

C.32

D.24

解答：

应该是D sizeof（类）计算的是类中存在栈中的变量的大小，而类中的b和*c都是static静态变量，存在全局区中，因此不在计算范围之内，于是只剩下char a，void *p和两个virtual虚函数，a是char类型，占用一个字节，p是指针，在64位系统的指针占用8个字节，而两个虚函数只需要一个虚函数表指针，也是八个字节，加上类中的对齐方式（char a对齐时后面补上7个字节），故答案为24.

### 知识点总结

1. **类成员的对齐与内存填充（padding）**

- 在C++中，编译器会对类的成员进行内存对齐（alignment），以提高访问效率，特别是在64位系统中，这意味着某些成员变量可能会被填充额外的字节以保证对齐。64位系统通常会以8字节为一组进行对齐。

2. **静态成员不占用类的对象空间**

- `static`成员变量属于类本身，而不是类的实例。所以类的实例不会为静态成员变量分配空间，它们不会影响`sizeof(C)`的结果。静态成员 `b` 和 `c` 在计算`sizeof`时不被考虑。

3. **指针大小**

- 在64位系统中，指针的大小为8字节（无论是对象指针还是函数指针）。在这个类中，`void *p` 是一个指针，因此占用8字节的空间。

4. **虚函数表（Virtual Table, vtable）**

- `C`类有两个虚函数 `func1()` 和 `func2()`，这意味着类对象需要保存一个指向虚函数表的指针，用来动态调度虚函数。在64位系统中，这个虚函数表指针也占用8字节的空间。

5. **成员变量的内存布局**

- `char a` 是1字节，但因为系统会以8字节对齐，所以后面会填充7个字节来保持后续指针变量的对齐。
- `void *p` 是8字节，紧接在第一个8字节位置的末尾。

## 例题2

以下关于STL各种容器和算法的sort和find函数对重载运算符的描述正确的是

A.二叉树类型的容器的sort和find都会调用operator <

B.线性类型容器sort会调用operator <

C.二叉树类型的容器的find会调用operator ==

D.线性类型容器使用std::find会调用operator ==

解答：

1. 二叉树类型的容器进行std::sort和std::find时，都会调用operator < 。

2. 线性类型(vector、list)容器进行std::sort算法时，会调用operator <；进行std::find时，会调用operator ==。

### 知识点总结

二叉树容器（如 set 和 map）不需要 sort 操作，find 也不会依赖 < 运算符。

线性容器（如 vector、deque、list）的 sort 调用 operator<

二叉树容器的 find 依赖 < 运算符，不使用 ==。

std::find 在线性容器中调用 operator== 进行查找。

## 例题3

有关构造函数的说法不正确的是（    ）

A.构造函数名字和类的名字一样

B.构造函数在定义变量时自动执行

C.构造函数无任何返回类型

D.构造函数有且只有一个

解答：

构造函数支持函数重载 另外还可以有拷贝构造函数 ，所以答案选D

### 知识点总结

构造函数没有返回类型，甚至不能返回 `void`。这是因为构造函数的作用是创建和初始化对象，而不是返回值。

## 例题4

静态局部变量存储在进程的（）。

A.栈区

B.寄存器区

C.代码区

D.全局区

解答：

全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的c语言中，全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存区,放在全局区

### 知识点总结

栈区（Stack）主要存放**函数的局部变量**（非静态的）和函数的调用信息，如函数参数、返回地址等。栈区的特点是**生命周期与函数调用周期一致**，在函数调用结束后，栈上的局部变量会被销毁。

寄存器（Register）用于存储一些短期的、频繁使用的数据，例如临时变量和运算中的中间结果，通常通过 `register` 关键字进行提示（但不强制使用寄存器）

代码区（Text Segment）存放的是程序的**机器指令**，也就是编译后的程序代码本身。程序的代码区是只读的，因此变量不会存储在这里。

全局区（Global Segment），又称为**静态存储区**，存放所有的**全局变量**和**静态变量**（包括静态局部变量）。静态局部变量虽然是在函数内部定义的，但它们的生命周期是整个程序的运行期，因此被存储在全局区中。

## 例题5

在32位操作系统中，我们定义如下变量 int (*n)[10]; 请问调用函数sizeof(n),返回值为（）

A.4

B.40

C.8

D.80

解答：

n 是指针变量，不论指针变量的类型是什么，在同一个平台下大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。

### 知识点总结

在同一个平台下指针变量的大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。

## 例题6

如果定义如下类：

class Empty{}

请选择编译器为之生成的函数有哪些？ （  ）

1.Empty() { … }

2.Empty(const Empty& rhs){ … }

3.Empty& operator=(const Empty& rhs) { … }

4.~Empty() { … }

A

124

B

1234

C

123

D

14

解答：

默认构造函数 

拷贝构造函数 

赋值运算符 

析构函数

### 知识点总结

 c++编译器至少给一个类添加4个函数  

   1.默认构造函数(无参，函数体为空)  

2. 默认析构函数(无参，函数体为空)  

3. 默认拷贝构造函数，对属性进行值拷贝  

4. 赋值运算符 operator=, 对属性进行值拷贝 

## 例题7

运算符重载以后，其优先级可以改变。

A.正确

B.错误

解答：

只能重载已有的且被允许重载的运算符； 重载后，运算符的优先级和结合性不会改变； 重载功能应当与原有功能类似，不能改变原运算符的操作对象个数，同时至少有一个操作对象是自定义类型。

### 总结的知识点

1. **运算符重载（Operator Overloading）**：
   - **定义**：运算符重载是指通过为已有运算符定义新的功能，使它们可以应用于用户自定义类型（如类、结构体等）。
   - **目的**：运算符重载可以让自定义类型使用像内置类型一样的运算符，从而使代码更加直观和易读。
2. **运算符的优先级和结合性**：
   - 运算符的**优先级**是由语言的语法规则预先定义的，决定了表达式中运算符的计算顺序。
   - 运算符的**结合性**（Associativity）决定了当相同优先级的运算符出现在一起时，运算的方向。
   - 运算符的优先级和结合性是**固定的**，无法通过重载来更改。
3. **运算符重载的作用**：
   - 运算符重载只会影响运算符的行为（即它如何对特定类型的数据进行运算），**不会改变运算符的优先级或结合性**。
   - 例如，`+` 运算符的优先级高于 `*`，这在运算符重载后依然成立。
4. **编写安全的运算符重载**：
   - 重载运算符时应保持其原有的直观含义，以避免混淆。例如，如果你重载 `+` 运算符，应该保持它有相加的行为。
   - 对于逻辑运算符、关系运算符等，建议确保返回值类型和内置运算符一致，以便程序逻辑更加清晰。

## 例题8

以下叙述中正确的是（）

A.使用typedef说明新类型名时，其格式是： typedef 新类型名 原类型名;

B.在程序中，允许用typedef来说明一种新的类型名

C.使用typedef 说明新类型名时，后面不能加分号

D.在使用typedef改变原类型的名称后，只能使用新的类型名

解答：

正确答案：B
A 选项错误，格式：typedef 原类型名 新类型名;
B 选项正确
C 选项错误，后面要加分号
D 选项错误，新的类型名和原类型名都可以使用

### 知识点总结

**`typedef` 的作用**：

- `typedef` 用于为已有的数据类型创建一个新的**别名**。通过使用 `typedef`，可以简化数据类型的书写，尤其是对于复杂的数据类型（如指针、结构体等）。

**`typedef` 的语法格式**：

```c++
typedef 原类型名 新类型名;
```

**分号的使用**：

- 在使用 `typedef` 定义新类型时，**必须**在语句的末尾加分号 (`;`)。

**原类型与新类型的共存**：

- 使用 `typedef` 创建的**新类型名**是原类型名的一个**别名**，并不是对原类型的替换。因此，在程序中可以**同时使用**新类型名和原类型名。

## 例题9

设有 N 个物体的坐标 (x, y, z) 和速度 (vx, vy, vz)，求经过 dt 时间之后物体的新坐标，以下有两种方式（C++）：

方法一：

```c++
struct Object {
  float x, y, z;
  float vx, vy, vz;
};
 
Object obj[N];
 
for (int i = 0; i < N; i++) {
  obj[i].x += obj[i].vx * dt;
  obj[i].y += obj[i].vy * dt;
  obj[i].z += obj[i].vz * dt;
}
```

方法二：

```c++
struct ObjectArray {
  float x[N], y[N], z[N];
  float vx[N], vy[N], vz[N];
};
 
ObjectArray obj_all;
 
for (int i = 0; i < N; i++) {
  obj_all.x[i] += obj_all.vx[i] * dt;
  obj_all.y[i] += obj_all.vy[i] * dt;
  obj_all.z[i] += obj_all.vz[i] * dt;
}
```

在最高级别的优化选项（-O3）下，两种方式运行速度相比（）

A.方法一运行速度更快

B.方法二运行速度更快

C.两种方法速度差不多

解答：

首先可以确定的是由于 C++ 的 0 开销抽象能力，因此二者在构造对象上性能不存在太大的差别。

关键是计算过程中方法二更好的利用了内存的局部性，cache miss 较少，更容易利用 SIMD 指令，速度更快。

### 知识点总结

1. **内存布局与缓存性能**：
   - **方法一**：结构体数组 (`obj[N]`) 中，每个 `Object` 对象都包含三个坐标和三个速度成员。因此，内存中相邻两个物体的坐标和速度并不连续存储。这样，在访问 `obj[i].x`, `obj[i].y`, `obj[i].z` 等成员时，可能会有**缓存不命中（cache miss）**的情况，导致性能下降。
   - **方法二**：数组结构 (`ObjectArray`) 把所有 `x` 坐标、`y` 坐标、`z` 坐标、以及速度都分开存储。访问 `obj_all.x[i]`, `obj_all.y[i]`, `obj_all.z[i]` 时，由于这些数据在内存中是连续存储的，**缓存命中率更高**，从而提高了访问速度。这种数据布局有助于更好地利用**缓存的空间局部性**，因此在更新大量物体数据时性能更高。
2. **结构体数组与数组结构的区别**：
   - **结构体数组**（Method 1）：内存中的数据是“交织”的，意味着一个 `Object` 中的所有属性紧挨在一起，然后是下一个 `Object`。
   - **数组结构**（Method 2）：内存中的数据是“解交织”的，所有的 `x` 值、`y` 值、`z` 值等分别存储在不同的数组中。
   - 在并行化或者矢量化（向量化）中，分离存储的结构更适合 SIMD 指令集的并行处理，因为它更易于进行**流水线优化**和**指令并行化**，而方法一的内存交织会造成较大的性能开销。
3. **内存访问模式和编译器优化**：
   - 在最高级别的编译优化选项（如 `-O3`）下，编译器会尽可能优化内存访问和指令执行顺序，以提升整体性能。
   - **方法二**的内存访问模式由于数据的连续性，可以让编译器更有效地进行**预取（prefetching）**，提高流水线效率，从而加速程序的执行。
4. **缓存的局部性**：
   - **空间局部性**指的是程序对内存中相邻位置的数据有较高的访问概率。如果访问的数据是连续存储的，那么更有可能利用 CPU 的缓存机制，提升运行效率。
   - 方法二的数据是以分离的形式存储，意味着每次处理坐标 `x` 时，下一次处理的坐标 `x` 也紧邻在缓存中，这符合**空间局部性**的原则。

## 例题10

关于内联函数说法错误的是:

A.不是任何一个函数都可定义成内联函数

B.内联函数的函数体内不能含有复杂的结构控制语句

C.递归函数可以被用来作为内联函数

D.内联函数一般适合于只有1~5行语句的小函数

解答：

内联函数是使用inline关键字声明的函数，也成内嵌函数，它主要的作用是解决程序的运行效率。 

使用内联函数的时候要注意： 

1.递归函数不能定义为内联函数 

2.内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。 

3.内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。 

4.对内联函数不能进行异常的接口声明。

### 知识点总结

**内联函数（Inline Function）**是C++中的一种用于提高程序性能的函数，它通过将函数的代码直接插入到调用函数的地方，减少函数调用的开销，从而提高程序的执行速度。

**内联函数的定义和特点：**

**定义**：

内联函数是在函数定义前使用关键字 `inline` 来声明的。例如：

```c++
inline int add(int a, int b) {
    return a + b;
}
```

编译器在编译时，会尝试将内联函数的代码直接展开在函数调用的地方，而不是进行常规的函数调用。

**特点**：

- **减少函数调用开销**：内联函数通过将代码展开，避免了普通函数调用中的压栈、跳转和返回等操作，消除了函数调用的时间消耗。
- **节省时间但增加空间**：由于内联函数的代码被复制到每一个调用的地方，如果函数体较大，且调用次数多，会导致代码体积增加，称为“代码膨胀”。
- **编译器的决定**：`inline` 关键字只是对编译器的**建议**，编译器可能会根据函数的复杂度和调用情况决定是否内联，特别是在编译器认为函数过于复杂或会增加不必要的内存使用时。
- **适合小函数**：内联函数通常适用于**代码量小且频繁调用**的函数，比如简单的数学运算、获取类成员的简单函数等。

**如何声明内联函数**：

**在类中声明的函数**：如果在类中直接定义的成员函数，编译器会自动将其视为内联函数（除非函数较为复杂）。

```c++
class Example {
public:
    int getValue() { return value; }  // 自动被视为内联函数
private:
    int value;
};
```

**使用 `inline` 关键字**：可以在类外部定义函数时显式声明为内联函数：

```c++
class Example {
public:
    inline int getValue();
};

inline int Example::getValue() {
    return value;
}
```

**内联函数的优缺点：**

**优点：**

1. **减少函数调用开销**：内联函数将代码展开，避免了常规函数调用中的栈帧创建、参数传递和返回等步骤，从而减少了时间开销。
2. **提高程序性能**：对于简单的小函数，如果调用频繁，将其内联可以显著提高程序的性能。

**缺点：**

1. **代码膨胀**：如果函数较大，且被频繁调用，内联展开会导致代码重复出现，增加可执行文件的体积，带来**代码膨胀**（Code Bloat）的缺点，可能会影响程序的缓存性能。
2. **编译时间增加**：内联函数的代码在编译时会被复制到每个调用点，因此编译器需要处理更多的代码量，可能会增加编译时间。
3. **递归函数不可内联**：内联函数无法进行递归调用，因为这会导致无限展开。

**适用场景：**

- **简单函数**：适合那些逻辑简单、代码量少的函数，例如获取某个值的 `getter` 函数，或者执行简单的数学运算。
- **频繁调用的函数**：对于频繁调用的简单函数，内联可以显著减少调用开销，从而提高性能。

## 例题11

假定MyClass为一个类，则该类的拷贝构造函数的声明语句是

A.MyClass(const MyClass x)

B.MyClass &(const MyClass x)

C.MyClass(const MyClass &x)

D.MyClass(const MyClass *x)

解答：

正确答案：C
拷贝构造函数的参数必须使用引用传递，并且使用 const 修饰。
使用引用是因为，如果不使用引用，那么调用时参数赋值时又会调用拷贝构造函数，就行程了死递归，并且使用引用还能减少数据的拷贝。
使用 const 是因为防止在函数内对原先的数据进行修改。

### 知识点总结

**拷贝构造函数的定义**

拷贝构造函数用于**通过已有对象来创建新对象**。在C++中，拷贝构造函数的典型形式是：

```c++
MyClass(const MyClass &x);
```

**题目选项分析**

1. **选项 A**: `MyClass(const MyClass x)`
   - 传参方式是**值传递**，会调用拷贝构造函数本身形成递归调用。通常情况下，这样的写法会引发编译错误或导致无限递归调用。
   - **错误的写法**。
2. **选项 B**: `MyClass &(const MyClass x)`
   - 返回类型为`MyClass &`，这不是构造函数的正确声明格式。构造函数没有返回类型。
   - **错误的写法**。
3. **选项 C**: `MyClass(const MyClass &x)`
   - 这是标准的拷贝构造函数声明方式，参数为**常量引用**，避免了不必要的拷贝并保证了效率。
   - **正确的写法**。
4. **选项 D**: `MyClass(const MyClass *x)`
   - 参数为指针，而不是引用。虽然可以定义这样的构造函数，但它不会被视为拷贝构造函数。拷贝构造函数必须以对象的引用作为参数。
   - **错误的写法**。

**知识点总结**

- 拷贝构造函数的标准形式是`MyClass(const MyClass &x)`，即接收同类型对象的常量引用。
- **拷贝构造函数不会有返回类型**。
- 值传递会导致递归调用构造函数本身，因此拷贝构造函数通常使用常量引用传参，避免额外拷贝。

## 例题12

对下面的程序段

```c++
#include<bits/stdc++.h>
using namespace std;
class CA
{
public:
    virtual void f1()
    {
        cout<<"CA::f1( )"<<endl;
        f2();
    }
    void f2()
    {
        cout<<"CA::f2( )"<<endl;
    }
};
class CB : public CA
{
public:
    void f1()
    {
        cout<<"CB::f1( )"<<endl;
        f2();
    }
    void f2()
    {
    cout<<"CB::f2( )"<<endl;
    }
};
class CC:public CB
{
public:
    virtual void f2()
    {
        cout<<"CC:f2()"<<endl;
    }
};
int main()
{
    CC c;
    CA *pA = &c ;
    pA->f1();
    return 0;
}
```

编译运行后，程序输出结果是（）

A

CB::f1() CC::f2()

B

CB::f1() CB::f2()

C

CB::f1() CA::f2()

D

CA::f1() CC::f2()

解答：

答案是B。 

  CA* pa =  &c;这句话是父类指针指向子类对象，调用pa->f1()时，因为父类中的f1()是虚函数，所以将发生动态绑定，调用子类CB中的f1()函数，先输出CB::f1() 

  在CB类的f1()函数中，调用非虚函数f2()，但因为其父类CA中的f2()函数并不是virtual函数，所以将调用CB类中的f2()函数，输出CB::f2()。如果将CA类中的f2()改成虚函数，那么将输出CC::f2()；如果将CB类中的f2()改成虚函数，也将输出CC::f2(),这是满足动态绑定的。

### 知识点总结

1. **虚函数（`virtual`）和多态**
   - 使用 `virtual` 关键字声明的函数会在运行时绑定（即动态绑定）。如果基类指针指向派生类对象，通过该指针调用虚函数时会调用派生类的实现。
2. **静态绑定和动态绑定**
   - **静态绑定**：非虚函数在编译期绑定，直接调用指定类的函数。
   - **动态绑定**：虚函数在运行时绑定，根据指针指向的实际对象类型调用相应的函数。
3. **虚函数覆盖**
   - 当派生类重新定义虚函数时，覆盖了基类中的定义，基类指针指向派生类对象时会调用派生类的实现。

## 例题13

下列说明语句中正确的是：

A

int a,&ra=a,&&ref=ra;

B

int &refa[10];

C

int a,&ra=a,&*refp=&ra;

D

int*pi, *&pref=pi;

解答：

A：引用只能一层，不能多层引用。 

  B：不允许使用引用的数组。 

  C：指针是指向一个对象的，引用是别名，不是对象，所以不能定义指向引用的指针。 

  D：指针的引用，可以理解为如下： 

```cpp
int *pi;
int *(&ref) = pi;
//类比
int a;
int &ra = a;
```

### 知识点总结

各个选项涉及 C++ 中**引用（Reference）**、**指针（Pointer）** 以及它们的组合使用。让我们逐一分析每个选项。

1. **选项 A**: `int a, &ra=a, &&ref=ra;`
   - `int a`：定义一个 `int` 类型变量 `a`。
   - `&ra = a`：`ra` 是 `a` 的引用，语法正确。
   - `&&ref = ra`：这是一个错误，因为 `&&` 表示**右值引用（rvalue reference）**，而 `ra` 是左值引用，不能绑定到右值引用。
   - **错误的写法**。
2. **选项 B**: `int &refa[10];`
   - `refa` 被定义为一个引用数组，这是不允许的，因为在 C++ 中**不允许定义引用的数组**。
   - **错误的写法**。
3. **选项 C**: `int a, &ra = a, &*refp = &ra;`
   - `&ra = a`：`ra` 是 `a` 的引用，语法正确。
   - `&*refp = &ra`：`&*refp` 表示先解引用指针然后取引用，这在语法上无意义，编译会报错。
   - **错误的写法**。
4. **选项 D**: `int *pi, *&pref = pi;`
   - `int *pi`：定义一个 `int` 指针 `pi`。
   - `*&pref = pi`：`pref` 是 `pi` 的引用，即`pref` 是**指针的引用**。
   - 语法正确。
   - **正确的写法**。

**知识点总结**

1. **左值引用和右值引用**
   - **左值引用**（`&`）：可用于引用一个变量（左值），如`int &ref = a`。
   - **右值引用**（`&&`）：只能用于绑定临时对象或右值，不能绑定到左值。
2. **引用数组**
   - C++ 中不允许定义引用的数组，因为引用需要在定义时就绑定对象，数组无法满足这一点。
3. **指针引用**
   - 可以定义指针的引用，即**指向指针的引用**，例如 `int *&pref = pi`，其中 `pref` 是 `pi` 的引用。

## 例题14

若有声明：int a[10];，则对数组元素的正确引用是（）

A

a[10]；

B

a[3.5]

C

a(5)

D

a[10-10]

解答：

因为定义的数组包含10个元素，对数组元素引用的下标是从0~9。显然a[10]超出了数组的范围，A是错误的引用。因数组下标的数据类型必须是整型，所以B是错误的。数组引用应使用中括号，小括号是非法的，所以C也是错误的。故正确答案是D，即引用a[0]。

### 知识点总结

1. **数组的声明和下标范围**

- 声明 `int a[10];` 表示定义了一个包含 10 个整数元素的数组 `a`，元素的下标从 `0` 到 `9`。
- 因此，正确的访问范围是 `a[0]` 到 `a[9]`，不能使用 `a[10]`，否则会超出数组范围，导致**越界错误**。

2. **数组下标的数据类型**

- 数组下标应当是**整数**，且可以是一个表达式。表达式的结果会被取整。
- 例如：`a[10-10]` 的值是 `a[0]`，这属于合法的数组下标访问方式。
- 使用小数作为下标（如 `a[3.5]`）是非法的，因为数组下标必须是整数类型，编译器会报错。

3. **数组下标的语法**

- 数组下标必须使用**方括号 `[]`**，而不是圆括号 `()`。如 `a(5)` 是非法的，编译器会报错。
- 使用圆括号是函数调用的语法，而不是数组下标引用的方式。****

## 例题15

以下程序段中，不能正确赋字符串（编译时系统会提示错误）的是（ ）

A

char s[10]="abcdefg";

B

char t[]="abcdefg",*s=t;

C

char s[10];s="abcdefg";

D

char s[10];strcpy(s,"abcdefg");

解答：

答案选C

数组名s是常量指针，代表数组的首地址，它的值不能被改变。

### 知识点总结

指针常量：是相对于指针变量而言的，也就是指针值不能修改的指针；常量指针：是指向常量的指针的简称，可以修改指针值，不能修改指向的实体。

1. **字符数组的初始化**

- 在声明字符数组时，可以直接使用双引号内的字符串对其进行初始化。
- 例如，`char s[10] = "abcdefg";`，这种方式会在 `s` 数组中存储 `"abcdefg"` 和终止符 `\0`，合法且编译不会出错。

2. **字符指针的使用**

- 可以将字符数组的地址赋给字符指针。
- 例如，`char t[] = "abcdefg"; char *s = t;`，其中 `s` 指向字符数组 `t` 的首地址，这是合法的。

3. **字符数组和字符指针的区别**

- **字符数组**：如 `char s[10];` 表示分配一个固定大小的数组（10 个字符），在数组内可以存储字符数据。
- **字符指针**：`char *s` 只是一个指针，可以指向任意一个字符数组或字符串的起始地址。
- 字符数组一旦定义，变量名 `s` 表示数组的首地址，不允许通过直接赋值的方式改变地址（例如 `s = "abcdefg";` 试图将字符数组重新赋值为一个字符串常量，这是非法的，会导致编译错误）。

4. **`strcpy` 函数的使用**

- `strcpy` 是字符串复制函数，用于将字符串常量或字符数组的内容复制到目标字符数组中。
- 用法：`strcpy(destination, source);`，例如 `strcpy(s, "abcdefg");` 会将 `"abcdefg"` 复制到字符数组 `s` 中，合法且不会产生编译错误。

## 例题16

下列for循环的循环体执行次数为

```c++
for(int i=10, j=1; i=j=0; i++, j--)
```

A

0

B

1

C

无限

D

以上都不对

解答：

for循环的条件判断语句 i=j=0 是一个赋值表达式，它的结果是它左侧运算对象，类型为左侧运算对象的类型。  

这里该表达式的值为0，而for在初始化后即进入条件判断语句，此时的条件判断结果是0，故不再执行循环体，即循环体执行次数为0。

### 知识点总结

**1. `for` 循环的基本结构**

一个 `for` 循环的基本格式为：

```
for (初始化表达式; 循环条件; 迭代表达式) {
    循环体
}
```

- **初始化表达式**：在循环开始时执行一次，用于初始化变量。
- **循环条件**：每次循环开始前检查条件是否为真。如果为真，执行循环体；否则，退出循环。
- **迭代表达式**：每次循环体执行完后执行，用于更新循环变量。

**2. `for` 循环条件的评估**

在 `for` 循环中，条件判断表达式的结果会被转换为布尔值：

- **非零值**：表示条件为真，继续执行循环体。
- **零值**：表示条件为假，退出循环。

**3. 题目中的关键点分析**

分析题目中的代码：

```C++
for (int i = 10, j = 1; i = j = 0; i++, j--)
```

- **初始化部分**：`int i = 10, j = 1;` 初始化了 `i` 为 `10`，`j` 为 `1`。

- 循环条件：

  ```C++
  i = j = 0
  ```

  - 这里是一个**赋值表达式**，从右到左计算。
  - `j = 0` 将 `j` 的值设置为 `0`，然后返回 `0`，将结果赋值给 `i`，所以 `i` 也被设置为 `0`。
  - 整个条件 `i = j = 0` 的最终值是 `0`。
  - 由于条件为 `0`（即 `false`），循环不会执行。

- **迭代表达式**和**循环体**：由于循环条件为假，循环体和迭代表达式不会执行。

## 例题17

在下列描述中，正确的是（）

A

虚函数是没有实现的函数

B

纯虚函数是返回值等于0的函数

C

抽象类是只有纯虚函数的类

D

抽象类指针可以指向不同的派生类

解答：

A 纯虚函数才是在基类中没有实现的函数 （虚函数是在基类中实现了，但是在派生类中可能有不同版本的函数） 错 

B 纯虚函数是在基类中等于0的函数 错 

C 抽象类是含有纯虚函数的类 错 

D 是对的，这是C++多态的性质

### 知识点总结

**1. 虚函数（Virtual Function）**

- **虚函数**是一种在基类中定义并允许在派生类中重写的函数，目的是实现**多态**。通过基类指针调用派生类的重写函数，可以实现动态绑定。
- 虚函数通常在基类中实现，但允许在派生类中重写。

**2. 纯虚函数（Pure Virtual Function）**

- **纯虚函数**是在基类中声明、没有实现的虚函数，表示基类只定义接口，具体实现留给派生类。

- 纯虚函数的语法是在函数声明后添加 `= 0`，例如：

  ```C++
  virtual void functionName() = 0;
  ```

- **纯虚函数不返回任何值**。`= 0` 只是语法，用于声明该函数是纯虚函数，并非返回值为 0。

**3. 抽象类（Abstract Class）**

- 包含**至少一个纯虚函数**的类被称为**抽象类**。抽象类不能实例化，但可以用作接口，派生类必须实现所有纯虚函数才能实例化。
- 抽象类可以包含普通成员函数、虚函数、甚至实现代码，不必所有函数都是纯虚函数。

**4. 抽象类指针的多态性**

- 抽象类的指针或引用可以指向不同的派生类对象，实现**多态**。

- 例如：

  ```C++
  AbstractClass* ptr = new DerivedClass();
  ```

  此时 `ptr`可以指向派生自 `AbstractClass`的任何派生类。

## 例题18

有以下一段代码：

```c++
#include <iostream>
using namespace std;
class A {
public :
    void run(void) {
        cout << "run()" << endl;
    }
    void run(int a){
        cout << "run(A)" << endl;
    }
};
class B : public A {
public :
    void run(int a) {
        cout << "run(B)" << endl;
    }
};
int main(void)　{
    B b;
    b.run(0);　　//语句1
    b.A::run(1); //语句2
    b.run(); //语句3
    b.A::run(); //语句4
    return 0;
}
```

编译时会产生错误的语句有：

A

语句1

B

语句2

C

语句3

D

语句4

解答：

函数同名，参数不同，virtual可有可无-->隐藏 函数同名，参数相同，无virtual-->隐藏，有virtual-->覆盖  

答案选C

### 知识点总结

**函数重载（Function Overloading）**

- 在同一个类中，允许定义多个同名函数，但要求它们的**参数列表**不同（参数的类型、数量或顺序不同）。重载函数在编译时根据参数列表来确定调用哪个函数。

**函数隐藏（Function Hiding）**

- 当派生类中定义了与基类同名的成员函数时，即使参数列表不同，基类中的所有同名函数都会被隐藏，导致基类的这些函数在派生类中无法直接访问。
- 例如，在类 `B` 中定义了 `void run(int a)`，这会隐藏基类 `A` 中的所有 `run` 函数。
- 如果希望访问被隐藏的基类函数，需要显式使用作用域操作符 `A::` 来调用基类中的 `run` 函数。

**基类成员函数的访问**

- 派生类对象可以通过**作用域解析符（`::`）**显式调用被隐藏的基类成员函数，例如 `b.A::run(1);`。
- 在派生类中，当函数被隐藏时，即使基类中存在函数重载，也无法直接调用，除非显式使用 `类名::函数名` 的方式调用基类的函数。

## 例题19

*p++ 自增 p 还是 p 所指向的变量?

A.自增 p

B.自增 p 所指向的变量

C.和机器相关

解答：

后缀++ 和-- 操作符本质上比前缀一目操作的优先级高, 因此`*p++ `和`*(p++) `等价, 它自增p 并返回p 自增之前所指向的值。 要自增p 指向的值, 使用`(*p)++`, 如果副作用的顺序无关紧要也可以使用`++*p`。

### 知识点总结

后缀++ 和-- 操作符本质上比前缀一目操作的优先级高

## 例题20

下面程序中， 输出是什么？

```c++
int fun(int x){
    int count = 0;
    while(x){
        count++;
        x = x &(x-1);
    }
    return count;
}
int main(){
    cout << "fun(2015)=" << fun(2015)<<endl;
}
```

A.fun(2015)=11

B.fun(2015)=10

C.fun(2015)=9

D.fun(2015)=8

解答：

本题是统计一个数有多少个1的，2015=11111011111共10个1.

### 知识点总结

**按位与（&）**：对应位都为 1，结果为 1；否则为 0。

**按位或（|）**：只要有一位为 1，结果为 1；否则为 0。

**按位异或（^）**：相同为 0，不同为 1。

**按位取反（~）**：将每个位翻转，0 变 1，1 变 0。

**左移（<<）**：将每个位向左移动指定的位数，右边补 0。左移一位相当于乘 2。

**右移（>>）**：将每个位向右移动指定的位数，左边补符号位（算术右移）或 0（逻辑右移）。

## 例题21

下列字符串可以用作C++标识符的是：

A._123

B.2009var

C.goto

D.test - 2009

解答：

  标识符 

  标识符用来表示函数、类型及变量的名称，是字母、下划线和数字的排列。 

  1、必须用字母或下划线开头。 

  2、只能是字母、下划线、数字的组合，不能出现其他符号。 

  2、大小写的含义是不同的。 

  3、标识符的名称不能是C语言中的关键字，关键字是具有特定含义的标识符 

### 知识点总结

**C++ 标识符命名规则**

1. **只能包含字母（大小写）、数字和下划线**。
2. **必须以字母或下划线开头**，不能以数字开头。
3. **不能使用 C++ 关键字**，因为关键字有特定含义。
4. **区分大小写**，因此 `Variable` 和 `variable` 是不同的标识符。

## 例题22

下列程序段执行后，输出d的值为()

```c++
int main()
{
   int a=1,b=0,c=-1,d=0;
   d=++a||++b&&++c;
   cout<<d<<endl;
   return 0;
}
```

A.1

B.2

C.3

D.0

解答：

运算符优先级：&&>||>=

所以先计算++b&&++c,++c为0，所以整体是false=0，再计算++a||0，++a为true，所以整体是true=1，所以d=1

### 知识点总结

**短路求值**：

- `||`（逻辑或）：当左侧表达式为 `true` 时，整个表达式立即为 `true`，右侧表达式不会被求值。
- `&&`（逻辑与）：当左侧表达式为 `false` 时，整个表达式立即为 `false`，右侧表达式不会被求值。

**前置递增运算符**：

- `++a` 会先将 `a` 加 1，然后返回新的值。
- 表达式中 `++a || ++b && ++c` 的 `||` 优先级低于 `&&`，因此先计算 `++b && ++c` 的结果，再将结果用于 `++a || (...)`。