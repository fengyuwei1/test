# C++理论练习

## 例题1

在64位系统中，有如下类：

```c++
class C
{
public:
    char a;
    static char b;
    void *p;
    static int *c;
    virtual void func1();
    virtual void func2();
};
```

那么sizeof（C）的数值是（）

A.9

B.17

C.32

D.24

解答：

应该是D sizeof（类）计算的是类中存在栈中的变量的大小，而类中的b和*c都是static静态变量，存在全局区中，因此不在计算范围之内，于是只剩下char a，void *p和两个virtual虚函数，a是char类型，占用一个字节，p是指针，在64位系统的指针占用8个字节，而两个虚函数只需要一个虚函数表指针，也是八个字节，加上类中的对齐方式（char a对齐时后面补上7个字节），故答案为24.

### 知识点总结

1. **类成员的对齐与内存填充（padding）**

- 在C++中，编译器会对类的成员进行内存对齐（alignment），以提高访问效率，特别是在64位系统中，这意味着某些成员变量可能会被填充额外的字节以保证对齐。64位系统通常会以8字节为一组进行对齐。

2. **静态成员不占用类的对象空间**

- `static`成员变量属于类本身，而不是类的实例。所以类的实例不会为静态成员变量分配空间，它们不会影响`sizeof(C)`的结果。静态成员 `b` 和 `c` 在计算`sizeof`时不被考虑。

3. **指针大小**

- 在64位系统中，指针的大小为8字节（无论是对象指针还是函数指针）。在这个类中，`void *p` 是一个指针，因此占用8字节的空间。

4. **虚函数表（Virtual Table, vtable）**

- `C`类有两个虚函数 `func1()` 和 `func2()`，这意味着类对象需要保存一个指向虚函数表的指针，用来动态调度虚函数。在64位系统中，这个虚函数表指针也占用8字节的空间。

5. **成员变量的内存布局**

- `char a` 是1字节，但因为系统会以8字节对齐，所以后面会填充7个字节来保持后续指针变量的对齐。
- `void *p` 是8字节，紧接在第一个8字节位置的末尾。

## 例题2

以下关于STL各种容器和算法的sort和find函数对重载运算符的描述正确的是

A.二叉树类型的容器的sort和find都会调用operator <

B.线性类型容器sort会调用operator <

C.二叉树类型的容器的find会调用operator ==

D.线性类型容器使用std::find会调用operator ==

解答：

1. 二叉树类型的容器进行std::sort和std::find时，都会调用operator < 。

2. 线性类型(vector、list)容器进行std::sort算法时，会调用operator <；进行std::find时，会调用operator ==。

### 知识点总结

二叉树容器（如 set 和 map）不需要 sort 操作，find 也不会依赖 < 运算符。

线性容器（如 vector、deque、list）的 sort 调用 operator<

二叉树容器的 find 依赖 < 运算符，不使用 ==。

std::find 在线性容器中调用 operator== 进行查找。

## 例题3

有关构造函数的说法不正确的是（    ）

A.构造函数名字和类的名字一样

B.构造函数在定义变量时自动执行

C.构造函数无任何返回类型

D.构造函数有且只有一个

解答：

构造函数支持函数重载 另外还可以有拷贝构造函数 ，所以答案选D

### 知识点总结

构造函数没有返回类型，甚至不能返回 `void`。这是因为构造函数的作用是创建和初始化对象，而不是返回值。

## 例题4

静态局部变量存储在进程的（）。

A.栈区

B.寄存器区

C.代码区

D.全局区

解答：

全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的c语言中，全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存区,放在全局区

### 知识点总结

栈区（Stack）主要存放**函数的局部变量**（非静态的）和函数的调用信息，如函数参数、返回地址等。栈区的特点是**生命周期与函数调用周期一致**，在函数调用结束后，栈上的局部变量会被销毁。

寄存器（Register）用于存储一些短期的、频繁使用的数据，例如临时变量和运算中的中间结果，通常通过 `register` 关键字进行提示（但不强制使用寄存器）

代码区（Text Segment）存放的是程序的**机器指令**，也就是编译后的程序代码本身。程序的代码区是只读的，因此变量不会存储在这里。

全局区（Global Segment），又称为**静态存储区**，存放所有的**全局变量**和**静态变量**（包括静态局部变量）。静态局部变量虽然是在函数内部定义的，但它们的生命周期是整个程序的运行期，因此被存储在全局区中。

## 例题5

在32位操作系统中，我们定义如下变量 int (*n)[10]; 请问调用函数sizeof(n),返回值为（）

A.4

B.40

C.8

D.80

解答：

n 是指针变量，不论指针变量的类型是什么，在同一个平台下大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。

### 知识点总结

在同一个平台下指针变量的大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。

## 例题6

如果定义如下类：

class Empty{}

请选择编译器为之生成的函数有哪些？ （  ）

1.Empty() { … }

2.Empty(const Empty& rhs){ … }

3.Empty& operator=(const Empty& rhs) { … }

4.~Empty() { … }

A

124

B

1234

C

123

D

14

解答：

默认构造函数 

拷贝构造函数 

赋值运算符 

析构函数

### 知识点总结

 c++编译器至少给一个类添加4个函数  

   1.默认构造函数(无参，函数体为空)  

2. 默认析构函数(无参，函数体为空)  

3. 默认拷贝构造函数，对属性进行值拷贝  

4. 赋值运算符 operator=, 对属性进行值拷贝 

## 例题7

运算符重载以后，其优先级可以改变。

A.正确

B.错误

解答：

只能重载已有的且被允许重载的运算符； 重载后，运算符的优先级和结合性不会改变； 重载功能应当与原有功能类似，不能改变原运算符的操作对象个数，同时至少有一个操作对象是自定义类型。

### 总结的知识点

1. **运算符重载（Operator Overloading）**：
   - **定义**：运算符重载是指通过为已有运算符定义新的功能，使它们可以应用于用户自定义类型（如类、结构体等）。
   - **目的**：运算符重载可以让自定义类型使用像内置类型一样的运算符，从而使代码更加直观和易读。
2. **运算符的优先级和结合性**：
   - 运算符的**优先级**是由语言的语法规则预先定义的，决定了表达式中运算符的计算顺序。
   - 运算符的**结合性**（Associativity）决定了当相同优先级的运算符出现在一起时，运算的方向。
   - 运算符的优先级和结合性是**固定的**，无法通过重载来更改。
3. **运算符重载的作用**：
   - 运算符重载只会影响运算符的行为（即它如何对特定类型的数据进行运算），**不会改变运算符的优先级或结合性**。
   - 例如，`+` 运算符的优先级高于 `*`，这在运算符重载后依然成立。
4. **编写安全的运算符重载**：
   - 重载运算符时应保持其原有的直观含义，以避免混淆。例如，如果你重载 `+` 运算符，应该保持它有相加的行为。
   - 对于逻辑运算符、关系运算符等，建议确保返回值类型和内置运算符一致，以便程序逻辑更加清晰。

## 例题8

以下叙述中正确的是（）

A.使用typedef说明新类型名时，其格式是： typedef 新类型名 原类型名;

B.在程序中，允许用typedef来说明一种新的类型名

C.使用typedef 说明新类型名时，后面不能加分号

D.在使用typedef改变原类型的名称后，只能使用新的类型名

解答：

正确答案：B
A 选项错误，格式：typedef 原类型名 新类型名;
B 选项正确
C 选项错误，后面要加分号
D 选项错误，新的类型名和原类型名都可以使用

### 知识点总结

**`typedef` 的作用**：

- `typedef` 用于为已有的数据类型创建一个新的**别名**。通过使用 `typedef`，可以简化数据类型的书写，尤其是对于复杂的数据类型（如指针、结构体等）。

**`typedef` 的语法格式**：

```c++
typedef 原类型名 新类型名;
```

**分号的使用**：

- 在使用 `typedef` 定义新类型时，**必须**在语句的末尾加分号 (`;`)。

**原类型与新类型的共存**：

- 使用 `typedef` 创建的**新类型名**是原类型名的一个**别名**，并不是对原类型的替换。因此，在程序中可以**同时使用**新类型名和原类型名。

## 例题9

设有 N 个物体的坐标 (x, y, z) 和速度 (vx, vy, vz)，求经过 dt 时间之后物体的新坐标，以下有两种方式（C++）：

方法一：

```c++
struct Object {
  float x, y, z;
  float vx, vy, vz;
};
 
Object obj[N];
 
for (int i = 0; i < N; i++) {
  obj[i].x += obj[i].vx * dt;
  obj[i].y += obj[i].vy * dt;
  obj[i].z += obj[i].vz * dt;
}
```

方法二：

```c++
struct ObjectArray {
  float x[N], y[N], z[N];
  float vx[N], vy[N], vz[N];
};
 
ObjectArray obj_all;
 
for (int i = 0; i < N; i++) {
  obj_all.x[i] += obj_all.vx[i] * dt;
  obj_all.y[i] += obj_all.vy[i] * dt;
  obj_all.z[i] += obj_all.vz[i] * dt;
}
```

在最高级别的优化选项（-O3）下，两种方式运行速度相比（）

A.方法一运行速度更快

B.方法二运行速度更快

C.两种方法速度差不多

解答：

首先可以确定的是由于 C++ 的 0 开销抽象能力，因此二者在构造对象上性能不存在太大的差别。

关键是计算过程中方法二更好的利用了内存的局部性，cache miss 较少，更容易利用 SIMD 指令，速度更快。

### 知识点总结

1. **内存布局与缓存性能**：
   - **方法一**：结构体数组 (`obj[N]`) 中，每个 `Object` 对象都包含三个坐标和三个速度成员。因此，内存中相邻两个物体的坐标和速度并不连续存储。这样，在访问 `obj[i].x`, `obj[i].y`, `obj[i].z` 等成员时，可能会有**缓存不命中（cache miss）**的情况，导致性能下降。
   - **方法二**：数组结构 (`ObjectArray`) 把所有 `x` 坐标、`y` 坐标、`z` 坐标、以及速度都分开存储。访问 `obj_all.x[i]`, `obj_all.y[i]`, `obj_all.z[i]` 时，由于这些数据在内存中是连续存储的，**缓存命中率更高**，从而提高了访问速度。这种数据布局有助于更好地利用**缓存的空间局部性**，因此在更新大量物体数据时性能更高。
2. **结构体数组与数组结构的区别**：
   - **结构体数组**（Method 1）：内存中的数据是“交织”的，意味着一个 `Object` 中的所有属性紧挨在一起，然后是下一个 `Object`。
   - **数组结构**（Method 2）：内存中的数据是“解交织”的，所有的 `x` 值、`y` 值、`z` 值等分别存储在不同的数组中。
   - 在并行化或者矢量化（向量化）中，分离存储的结构更适合 SIMD 指令集的并行处理，因为它更易于进行**流水线优化**和**指令并行化**，而方法一的内存交织会造成较大的性能开销。
3. **内存访问模式和编译器优化**：
   - 在最高级别的编译优化选项（如 `-O3`）下，编译器会尽可能优化内存访问和指令执行顺序，以提升整体性能。
   - **方法二**的内存访问模式由于数据的连续性，可以让编译器更有效地进行**预取（prefetching）**，提高流水线效率，从而加速程序的执行。
4. **缓存的局部性**：
   - **空间局部性**指的是程序对内存中相邻位置的数据有较高的访问概率。如果访问的数据是连续存储的，那么更有可能利用 CPU 的缓存机制，提升运行效率。
   - 方法二的数据是以分离的形式存储，意味着每次处理坐标 `x` 时，下一次处理的坐标 `x` 也紧邻在缓存中，这符合**空间局部性**的原则。

## 例题10

关于内联函数说法错误的是:

A.不是任何一个函数都可定义成内联函数

B.内联函数的函数体内不能含有复杂的结构控制语句

C.递归函数可以被用来作为内联函数

D.内联函数一般适合于只有1~5行语句的小函数

解答：

内联函数是使用inline关键字声明的函数，也成内嵌函数，它主要的作用是解决程序的运行效率。 

使用内联函数的时候要注意： 

1.递归函数不能定义为内联函数 

2.内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。 

3.内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。 

4.对内联函数不能进行异常的接口声明。

### 知识点总结

**内联函数（Inline Function）**是C++中的一种用于提高程序性能的函数，它通过将函数的代码直接插入到调用函数的地方，减少函数调用的开销，从而提高程序的执行速度。

**内联函数的定义和特点：**

**定义**：

内联函数是在函数定义前使用关键字 `inline` 来声明的。例如：

```c++
inline int add(int a, int b) {
    return a + b;
}
```

编译器在编译时，会尝试将内联函数的代码直接展开在函数调用的地方，而不是进行常规的函数调用。

**特点**：

- **减少函数调用开销**：内联函数通过将代码展开，避免了普通函数调用中的压栈、跳转和返回等操作，消除了函数调用的时间消耗。
- **节省时间但增加空间**：由于内联函数的代码被复制到每一个调用的地方，如果函数体较大，且调用次数多，会导致代码体积增加，称为“代码膨胀”。
- **编译器的决定**：`inline` 关键字只是对编译器的**建议**，编译器可能会根据函数的复杂度和调用情况决定是否内联，特别是在编译器认为函数过于复杂或会增加不必要的内存使用时。
- **适合小函数**：内联函数通常适用于**代码量小且频繁调用**的函数，比如简单的数学运算、获取类成员的简单函数等。

**如何声明内联函数**：

**在类中声明的函数**：如果在类中直接定义的成员函数，编译器会自动将其视为内联函数（除非函数较为复杂）。

```c++
class Example {
public:
    int getValue() { return value; }  // 自动被视为内联函数
private:
    int value;
};
```

**使用 `inline` 关键字**：可以在类外部定义函数时显式声明为内联函数：

```c++
class Example {
public:
    inline int getValue();
};

inline int Example::getValue() {
    return value;
}
```

**内联函数的优缺点：**

**优点：**

1. **减少函数调用开销**：内联函数将代码展开，避免了常规函数调用中的栈帧创建、参数传递和返回等步骤，从而减少了时间开销。
2. **提高程序性能**：对于简单的小函数，如果调用频繁，将其内联可以显著提高程序的性能。

**缺点：**

1. **代码膨胀**：如果函数较大，且被频繁调用，内联展开会导致代码重复出现，增加可执行文件的体积，带来**代码膨胀**（Code Bloat）的缺点，可能会影响程序的缓存性能。
2. **编译时间增加**：内联函数的代码在编译时会被复制到每个调用点，因此编译器需要处理更多的代码量，可能会增加编译时间。
3. **递归函数不可内联**：内联函数无法进行递归调用，因为这会导致无限展开。

**适用场景：**

- **简单函数**：适合那些逻辑简单、代码量少的函数，例如获取某个值的 `getter` 函数，或者执行简单的数学运算。
- **频繁调用的函数**：对于频繁调用的简单函数，内联可以显著减少调用开销，从而提高性能。

## 例题11

假定MyClass为一个类，则该类的拷贝构造函数的声明语句是

A.MyClass(const MyClass x)

B.MyClass &(const MyClass x)

C.MyClass(const MyClass &x)

D.MyClass(const MyClass *x)

解答：

正确答案：C
拷贝构造函数的参数必须使用引用传递，并且使用 const 修饰。
使用引用是因为，如果不使用引用，那么调用时参数赋值时又会调用拷贝构造函数，就行程了死递归，并且使用引用还能减少数据的拷贝。
使用 const 是因为防止在函数内对原先的数据进行修改。

### 知识点总结

**拷贝构造函数的定义**

拷贝构造函数用于**通过已有对象来创建新对象**。在C++中，拷贝构造函数的典型形式是：

```c++
MyClass(const MyClass &x);
```

**题目选项分析**

1. **选项 A**: `MyClass(const MyClass x)`
   - 传参方式是**值传递**，会调用拷贝构造函数本身形成递归调用。通常情况下，这样的写法会引发编译错误或导致无限递归调用。
   - **错误的写法**。
2. **选项 B**: `MyClass &(const MyClass x)`
   - 返回类型为`MyClass &`，这不是构造函数的正确声明格式。构造函数没有返回类型。
   - **错误的写法**。
3. **选项 C**: `MyClass(const MyClass &x)`
   - 这是标准的拷贝构造函数声明方式，参数为**常量引用**，避免了不必要的拷贝并保证了效率。
   - **正确的写法**。
4. **选项 D**: `MyClass(const MyClass *x)`
   - 参数为指针，而不是引用。虽然可以定义这样的构造函数，但它不会被视为拷贝构造函数。拷贝构造函数必须以对象的引用作为参数。
   - **错误的写法**。

**知识点总结**

- 拷贝构造函数的标准形式是`MyClass(const MyClass &x)`，即接收同类型对象的常量引用。
- **拷贝构造函数不会有返回类型**。
- 值传递会导致递归调用构造函数本身，因此拷贝构造函数通常使用常量引用传参，避免额外拷贝。

## 例题12

对下面的程序段

```c++
#include<bits/stdc++.h>
using namespace std;
class CA
{
public:
    virtual void f1()
    {
        cout<<"CA::f1( )"<<endl;
        f2();
    }
    void f2()
    {
        cout<<"CA::f2( )"<<endl;
    }
};
class CB : public CA
{
public:
    void f1()
    {
        cout<<"CB::f1( )"<<endl;
        f2();
    }
    void f2()
    {
    cout<<"CB::f2( )"<<endl;
    }
};
class CC:public CB
{
public:
    virtual void f2()
    {
        cout<<"CC:f2()"<<endl;
    }
};
int main()
{
    CC c;
    CA *pA = &c ;
    pA->f1();
    return 0;
}
```

编译运行后，程序输出结果是（）

A

CB::f1() CC::f2()

B

CB::f1() CB::f2()

C

CB::f1() CA::f2()

D

CA::f1() CC::f2()

解答：

答案是B。 

  CA* pa =  &c;这句话是父类指针指向子类对象，调用pa->f1()时，因为父类中的f1()是虚函数，所以将发生动态绑定，调用子类CB中的f1()函数，先输出CB::f1() 

  在CB类的f1()函数中，调用非虚函数f2()，但因为其父类CA中的f2()函数并不是virtual函数，所以将调用CB类中的f2()函数，输出CB::f2()。如果将CA类中的f2()改成虚函数，那么将输出CC::f2()；如果将CB类中的f2()改成虚函数，也将输出CC::f2(),这是满足动态绑定的。

### 知识点总结

1. **虚函数（`virtual`）和多态**
   - 使用 `virtual` 关键字声明的函数会在运行时绑定（即动态绑定）。如果基类指针指向派生类对象，通过该指针调用虚函数时会调用派生类的实现。
2. **静态绑定和动态绑定**
   - **静态绑定**：非虚函数在编译期绑定，直接调用指定类的函数。
   - **动态绑定**：虚函数在运行时绑定，根据指针指向的实际对象类型调用相应的函数。
3. **虚函数覆盖**
   - 当派生类重新定义虚函数时，覆盖了基类中的定义，基类指针指向派生类对象时会调用派生类的实现。

## 例题13

下列说明语句中正确的是：

A

int a,&ra=a,&&ref=ra;

B

int &refa[10];

C

int a,&ra=a,&*refp=&ra;

D

int*pi, *&pref=pi;

解答：

A：引用只能一层，不能多层引用。 

  B：不允许使用引用的数组。 

  C：指针是指向一个对象的，引用是别名，不是对象，所以不能定义指向引用的指针。 

  D：指针的引用，可以理解为如下： 

```cpp
int *pi;
int *(&ref) = pi;
//类比
int a;
int &ra = a;
```

### 知识点总结

各个选项涉及 C++ 中**引用（Reference）**、**指针（Pointer）** 以及它们的组合使用。让我们逐一分析每个选项。

1. **选项 A**: `int a, &ra=a, &&ref=ra;`
   - `int a`：定义一个 `int` 类型变量 `a`。
   - `&ra = a`：`ra` 是 `a` 的引用，语法正确。
   - `&&ref = ra`：这是一个错误，因为 `&&` 表示**右值引用（rvalue reference）**，而 `ra` 是左值引用，不能绑定到右值引用。
   - **错误的写法**。
2. **选项 B**: `int &refa[10];`
   - `refa` 被定义为一个引用数组，这是不允许的，因为在 C++ 中**不允许定义引用的数组**。
   - **错误的写法**。
3. **选项 C**: `int a, &ra = a, &*refp = &ra;`
   - `&ra = a`：`ra` 是 `a` 的引用，语法正确。
   - `&*refp = &ra`：`&*refp` 表示先解引用指针然后取引用，这在语法上无意义，编译会报错。
   - **错误的写法**。
4. **选项 D**: `int *pi, *&pref = pi;`
   - `int *pi`：定义一个 `int` 指针 `pi`。
   - `*&pref = pi`：`pref` 是 `pi` 的引用，即`pref` 是**指针的引用**。
   - 语法正确。
   - **正确的写法**。

**知识点总结**

1. **左值引用和右值引用**
   - **左值引用**（`&`）：可用于引用一个变量（左值），如`int &ref = a`。
   - **右值引用**（`&&`）：只能用于绑定临时对象或右值，不能绑定到左值。
2. **引用数组**
   - C++ 中不允许定义引用的数组，因为引用需要在定义时就绑定对象，数组无法满足这一点。
3. **指针引用**
   - 可以定义指针的引用，即**指向指针的引用**，例如 `int *&pref = pi`，其中 `pref` 是 `pi` 的引用。

### 