# C++理论练习

## 例题1

在64位系统中，有如下类：

```c++
class C
{
public:
    char a;
    static char b;
    void *p;
    static int *c;
    virtual void func1();
    virtual void func2();
};
```

那么sizeof（C）的数值是（）

A.9

B.17

C.32

D.24

解答：

应该是D sizeof（类）计算的是类中存在栈中的变量的大小，而类中的b和*c都是static静态变量，存在全局区中，因此不在计算范围之内，于是只剩下char a，void *p和两个virtual虚函数，a是char类型，占用一个字节，p是指针，在64位系统的指针占用8个字节，而两个虚函数只需要一个虚函数表指针，也是八个字节，加上类中的对齐方式（char a对齐时后面补上7个字节），故答案为24.

### 知识点总结

1. **类成员的对齐与内存填充（padding）**

- 在C++中，编译器会对类的成员进行内存对齐（alignment），以提高访问效率，特别是在64位系统中，这意味着某些成员变量可能会被填充额外的字节以保证对齐。64位系统通常会以8字节为一组进行对齐。

2. **静态成员不占用类的对象空间**

- `static`成员变量属于类本身，而不是类的实例。所以类的实例不会为静态成员变量分配空间，它们不会影响`sizeof(C)`的结果。静态成员 `b` 和 `c` 在计算`sizeof`时不被考虑。

3. **指针大小**

- 在64位系统中，指针的大小为8字节（无论是对象指针还是函数指针）。在这个类中，`void *p` 是一个指针，因此占用8字节的空间。

4. **虚函数表（Virtual Table, vtable）**

- `C`类有两个虚函数 `func1()` 和 `func2()`，这意味着类对象需要保存一个指向虚函数表的指针，用来动态调度虚函数。在64位系统中，这个虚函数表指针也占用8字节的空间。

5. **成员变量的内存布局**

- `char a` 是1字节，但因为系统会以8字节对齐，所以后面会填充7个字节来保持后续指针变量的对齐。
- `void *p` 是8字节，紧接在第一个8字节位置的末尾。

## 例题2

以下关于STL各种容器和算法的sort和find函数对重载运算符的描述正确的是

A.二叉树类型的容器的sort和find都会调用operator <

B.线性类型容器sort会调用operator <

C.二叉树类型的容器的find会调用operator ==

D.线性类型容器使用std::find会调用operator ==

解答：

1. 二叉树类型的容器进行std::sort和std::find时，都会调用operator < 。

2. 线性类型(vector、list)容器进行std::sort算法时，会调用operator <；进行std::find时，会调用operator ==。

### 知识点总结

二叉树容器（如 set 和 map）不需要 sort 操作，find 也不会依赖 < 运算符。

线性容器（如 vector、deque、list）的 sort 调用 operator<

二叉树容器的 find 依赖 < 运算符，不使用 ==。

std::find 在线性容器中调用 operator== 进行查找。

## 例题3

有关构造函数的说法不正确的是（    ）

A.构造函数名字和类的名字一样

B.构造函数在定义变量时自动执行

C.构造函数无任何返回类型

D.构造函数有且只有一个

解答：

构造函数支持函数重载 另外还可以有拷贝构造函数 ，所以答案选D

### 知识点总结

构造函数没有返回类型，甚至不能返回 `void`。这是因为构造函数的作用是创建和初始化对象，而不是返回值。

## 例题4

静态局部变量存储在进程的（）。

A.栈区

B.寄存器区

C.代码区

D.全局区

解答：

全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的c语言中，全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存区,放在全局区

### 知识点总结

栈区（Stack）主要存放**函数的局部变量**（非静态的）和函数的调用信息，如函数参数、返回地址等。栈区的特点是**生命周期与函数调用周期一致**，在函数调用结束后，栈上的局部变量会被销毁。

寄存器（Register）用于存储一些短期的、频繁使用的数据，例如临时变量和运算中的中间结果，通常通过 `register` 关键字进行提示（但不强制使用寄存器）

代码区（Text Segment）存放的是程序的**机器指令**，也就是编译后的程序代码本身。程序的代码区是只读的，因此变量不会存储在这里。

全局区（Global Segment），又称为**静态存储区**，存放所有的**全局变量**和**静态变量**（包括静态局部变量）。静态局部变量虽然是在函数内部定义的，但它们的生命周期是整个程序的运行期，因此被存储在全局区中。

## 例题5

在32位操作系统中，我们定义如下变量 int (*n)[10]; 请问调用函数sizeof(n),返回值为（）

A.4

B.40

C.8

D.80

解答：

n 是指针变量，不论指针变量的类型是什么，在同一个平台下大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。

### 知识点总结

在同一个平台下指针变量的大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。

## 例题6

如果定义如下类：

class Empty{}

请选择编译器为之生成的函数有哪些？ （  ）

1.Empty() { … }

2.Empty(const Empty& rhs){ … }

3.Empty& operator=(const Empty& rhs) { … }

4.~Empty() { … }

A

124

B

1234

C

123

D

14

解答：

默认构造函数 

拷贝构造函数 

赋值运算符 

析构函数

### 知识点总结

 c++编译器至少给一个类添加4个函数  

   1.默认构造函数(无参，函数体为空)  

2. 默认析构函数(无参，函数体为空)  

3. 默认拷贝构造函数，对属性进行值拷贝  

4. 赋值运算符 operator=, 对属性进行值拷贝 

## 例题7

运算符重载以后，其优先级可以改变。

A.正确

B.错误

解答：

只能重载已有的且被允许重载的运算符； 重载后，运算符的优先级和结合性不会改变； 重载功能应当与原有功能类似，不能改变原运算符的操作对象个数，同时至少有一个操作对象是自定义类型。

### 总结的知识点

1. **运算符重载（Operator Overloading）**：
   - **定义**：运算符重载是指通过为已有运算符定义新的功能，使它们可以应用于用户自定义类型（如类、结构体等）。
   - **目的**：运算符重载可以让自定义类型使用像内置类型一样的运算符，从而使代码更加直观和易读。
2. **运算符的优先级和结合性**：
   - 运算符的**优先级**是由语言的语法规则预先定义的，决定了表达式中运算符的计算顺序。
   - 运算符的**结合性**（Associativity）决定了当相同优先级的运算符出现在一起时，运算的方向。
   - 运算符的优先级和结合性是**固定的**，无法通过重载来更改。
3. **运算符重载的作用**：
   - 运算符重载只会影响运算符的行为（即它如何对特定类型的数据进行运算），**不会改变运算符的优先级或结合性**。
   - 例如，`+` 运算符的优先级高于 `*`，这在运算符重载后依然成立。
4. **编写安全的运算符重载**：
   - 重载运算符时应保持其原有的直观含义，以避免混淆。例如，如果你重载 `+` 运算符，应该保持它有相加的行为。
   - 对于逻辑运算符、关系运算符等，建议确保返回值类型和内置运算符一致，以便程序逻辑更加清晰。

## 例题8

以下叙述中正确的是（）

A.使用typedef说明新类型名时，其格式是： typedef 新类型名 原类型名;

B.在程序中，允许用typedef来说明一种新的类型名

C.使用typedef 说明新类型名时，后面不能加分号

D.在使用typedef改变原类型的名称后，只能使用新的类型名

解答：

正确答案：B
A 选项错误，格式：typedef 原类型名 新类型名;
B 选项正确
C 选项错误，后面要加分号
D 选项错误，新的类型名和原类型名都可以使用

### 知识点总结

**`typedef` 的作用**：

- `typedef` 用于为已有的数据类型创建一个新的**别名**。通过使用 `typedef`，可以简化数据类型的书写，尤其是对于复杂的数据类型（如指针、结构体等）。

**`typedef` 的语法格式**：

```c++
typedef 原类型名 新类型名;
```

**分号的使用**：

- 在使用 `typedef` 定义新类型时，**必须**在语句的末尾加分号 (`;`)。

**原类型与新类型的共存**：

- 使用 `typedef` 创建的**新类型名**是原类型名的一个**别名**，并不是对原类型的替换。因此，在程序中可以**同时使用**新类型名和原类型名。

## 例题9

设有 N 个物体的坐标 (x, y, z) 和速度 (vx, vy, vz)，求经过 dt 时间之后物体的新坐标，以下有两种方式（C++）：

方法一：

```c++
struct Object {
  float x, y, z;
  float vx, vy, vz;
};
 
Object obj[N];
 
for (int i = 0; i < N; i++) {
  obj[i].x += obj[i].vx * dt;
  obj[i].y += obj[i].vy * dt;
  obj[i].z += obj[i].vz * dt;
}
```

方法二：

```c++
struct ObjectArray {
  float x[N], y[N], z[N];
  float vx[N], vy[N], vz[N];
};
 
ObjectArray obj_all;
 
for (int i = 0; i < N; i++) {
  obj_all.x[i] += obj_all.vx[i] * dt;
  obj_all.y[i] += obj_all.vy[i] * dt;
  obj_all.z[i] += obj_all.vz[i] * dt;
}
```

在最高级别的优化选项（-O3）下，两种方式运行速度相比（）

A.方法一运行速度更快

B.方法二运行速度更快

C.两种方法速度差不多

解答：

首先可以确定的是由于 C++ 的 0 开销抽象能力，因此二者在构造对象上性能不存在太大的差别。

关键是计算过程中方法二更好的利用了内存的局部性，cache miss 较少，更容易利用 SIMD 指令，速度更快。

### 知识点总结

1. **内存布局与缓存性能**：
   - **方法一**：结构体数组 (`obj[N]`) 中，每个 `Object` 对象都包含三个坐标和三个速度成员。因此，内存中相邻两个物体的坐标和速度并不连续存储。这样，在访问 `obj[i].x`, `obj[i].y`, `obj[i].z` 等成员时，可能会有**缓存不命中（cache miss）**的情况，导致性能下降。
   - **方法二**：数组结构 (`ObjectArray`) 把所有 `x` 坐标、`y` 坐标、`z` 坐标、以及速度都分开存储。访问 `obj_all.x[i]`, `obj_all.y[i]`, `obj_all.z[i]` 时，由于这些数据在内存中是连续存储的，**缓存命中率更高**，从而提高了访问速度。这种数据布局有助于更好地利用**缓存的空间局部性**，因此在更新大量物体数据时性能更高。
2. **结构体数组与数组结构的区别**：
   - **结构体数组**（Method 1）：内存中的数据是“交织”的，意味着一个 `Object` 中的所有属性紧挨在一起，然后是下一个 `Object`。
   - **数组结构**（Method 2）：内存中的数据是“解交织”的，所有的 `x` 值、`y` 值、`z` 值等分别存储在不同的数组中。
   - 在并行化或者矢量化（向量化）中，分离存储的结构更适合 SIMD 指令集的并行处理，因为它更易于进行**流水线优化**和**指令并行化**，而方法一的内存交织会造成较大的性能开销。
3. **内存访问模式和编译器优化**：
   - 在最高级别的编译优化选项（如 `-O3`）下，编译器会尽可能优化内存访问和指令执行顺序，以提升整体性能。
   - **方法二**的内存访问模式由于数据的连续性，可以让编译器更有效地进行**预取（prefetching）**，提高流水线效率，从而加速程序的执行。
4. **缓存的局部性**：
   - **空间局部性**指的是程序对内存中相邻位置的数据有较高的访问概率。如果访问的数据是连续存储的，那么更有可能利用 CPU 的缓存机制，提升运行效率。
   - 方法二的数据是以分离的形式存储，意味着每次处理坐标 `x` 时，下一次处理的坐标 `x` 也紧邻在缓存中，这符合**空间局部性**的原则。

## 例题10

关于内联函数说法错误的是:

A.不是任何一个函数都可定义成内联函数

B.内联函数的函数体内不能含有复杂的结构控制语句

C.递归函数可以被用来作为内联函数

D.内联函数一般适合于只有1~5行语句的小函数

解答：

内联函数是使用inline关键字声明的函数，也成内嵌函数，它主要的作用是解决程序的运行效率。 

使用内联函数的时候要注意： 

1.递归函数不能定义为内联函数 

2.内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。 

3.内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。 

4.对内联函数不能进行异常的接口声明。

### 知识点总结

**内联函数（Inline Function）**是C++中的一种用于提高程序性能的函数，它通过将函数的代码直接插入到调用函数的地方，减少函数调用的开销，从而提高程序的执行速度。

**内联函数的定义和特点：**

**定义**：

内联函数是在函数定义前使用关键字 `inline` 来声明的。例如：

```c++
inline int add(int a, int b) {
    return a + b;
}
```

编译器在编译时，会尝试将内联函数的代码直接展开在函数调用的地方，而不是进行常规的函数调用。

**特点**：

- **减少函数调用开销**：内联函数通过将代码展开，避免了普通函数调用中的压栈、跳转和返回等操作，消除了函数调用的时间消耗。
- **节省时间但增加空间**：由于内联函数的代码被复制到每一个调用的地方，如果函数体较大，且调用次数多，会导致代码体积增加，称为“代码膨胀”。
- **编译器的决定**：`inline` 关键字只是对编译器的**建议**，编译器可能会根据函数的复杂度和调用情况决定是否内联，特别是在编译器认为函数过于复杂或会增加不必要的内存使用时。
- **适合小函数**：内联函数通常适用于**代码量小且频繁调用**的函数，比如简单的数学运算、获取类成员的简单函数等。

**如何声明内联函数**：

**在类中声明的函数**：如果在类中直接定义的成员函数，编译器会自动将其视为内联函数（除非函数较为复杂）。

```c++
class Example {
public:
    int getValue() { return value; }  // 自动被视为内联函数
private:
    int value;
};
```

**使用 `inline` 关键字**：可以在类外部定义函数时显式声明为内联函数：

```c++
class Example {
public:
    inline int getValue();
};

inline int Example::getValue() {
    return value;
}
```

**内联函数的优缺点：**

**优点：**

1. **减少函数调用开销**：内联函数将代码展开，避免了常规函数调用中的栈帧创建、参数传递和返回等步骤，从而减少了时间开销。
2. **提高程序性能**：对于简单的小函数，如果调用频繁，将其内联可以显著提高程序的性能。

**缺点：**

1. **代码膨胀**：如果函数较大，且被频繁调用，内联展开会导致代码重复出现，增加可执行文件的体积，带来**代码膨胀**（Code Bloat）的缺点，可能会影响程序的缓存性能。
2. **编译时间增加**：内联函数的代码在编译时会被复制到每个调用点，因此编译器需要处理更多的代码量，可能会增加编译时间。
3. **递归函数不可内联**：内联函数无法进行递归调用，因为这会导致无限展开。

**适用场景：**

- **简单函数**：适合那些逻辑简单、代码量少的函数，例如获取某个值的 `getter` 函数，或者执行简单的数学运算。
- **频繁调用的函数**：对于频繁调用的简单函数，内联可以显著减少调用开销，从而提高性能。

## 例题11

假定MyClass为一个类，则该类的拷贝构造函数的声明语句是

A.MyClass(const MyClass x)

B.MyClass &(const MyClass x)

C.MyClass(const MyClass &x)

D.MyClass(const MyClass *x)

解答：

正确答案：C
拷贝构造函数的参数必须使用引用传递，并且使用 const 修饰。
使用引用是因为，如果不使用引用，那么调用时参数赋值时又会调用拷贝构造函数，就行程了死递归，并且使用引用还能减少数据的拷贝。
使用 const 是因为防止在函数内对原先的数据进行修改。

### 知识点总结

**拷贝构造函数的定义**

拷贝构造函数用于**通过已有对象来创建新对象**。在C++中，拷贝构造函数的典型形式是：

```c++
MyClass(const MyClass &x);
```

**题目选项分析**

1. **选项 A**: `MyClass(const MyClass x)`
   - 传参方式是**值传递**，会调用拷贝构造函数本身形成递归调用。通常情况下，这样的写法会引发编译错误或导致无限递归调用。
   - **错误的写法**。
2. **选项 B**: `MyClass &(const MyClass x)`
   - 返回类型为`MyClass &`，这不是构造函数的正确声明格式。构造函数没有返回类型。
   - **错误的写法**。
3. **选项 C**: `MyClass(const MyClass &x)`
   - 这是标准的拷贝构造函数声明方式，参数为**常量引用**，避免了不必要的拷贝并保证了效率。
   - **正确的写法**。
4. **选项 D**: `MyClass(const MyClass *x)`
   - 参数为指针，而不是引用。虽然可以定义这样的构造函数，但它不会被视为拷贝构造函数。拷贝构造函数必须以对象的引用作为参数。
   - **错误的写法**。

**知识点总结**

- 拷贝构造函数的标准形式是`MyClass(const MyClass &x)`，即接收同类型对象的常量引用。
- **拷贝构造函数不会有返回类型**。
- 值传递会导致递归调用构造函数本身，因此拷贝构造函数通常使用常量引用传参，避免额外拷贝。

## 例题12

对下面的程序段

```c++
#include<bits/stdc++.h>
using namespace std;
class CA
{
public:
    virtual void f1()
    {
        cout<<"CA::f1( )"<<endl;
        f2();
    }
    void f2()
    {
        cout<<"CA::f2( )"<<endl;
    }
};
class CB : public CA
{
public:
    void f1()
    {
        cout<<"CB::f1( )"<<endl;
        f2();
    }
    void f2()
    {
    cout<<"CB::f2( )"<<endl;
    }
};
class CC:public CB
{
public:
    virtual void f2()
    {
        cout<<"CC:f2()"<<endl;
    }
};
int main()
{
    CC c;
    CA *pA = &c ;
    pA->f1();
    return 0;
}
```

编译运行后，程序输出结果是（）

A

CB::f1() CC::f2()

B

CB::f1() CB::f2()

C

CB::f1() CA::f2()

D

CA::f1() CC::f2()

解答：

答案是B。 

  CA* pa =  &c;这句话是父类指针指向子类对象，调用pa->f1()时，因为父类中的f1()是虚函数，所以将发生动态绑定，调用子类CB中的f1()函数，先输出CB::f1() 

  在CB类的f1()函数中，调用非虚函数f2()，但因为其父类CA中的f2()函数并不是virtual函数，所以将调用CB类中的f2()函数，输出CB::f2()。如果将CA类中的f2()改成虚函数，那么将输出CC::f2()；如果将CB类中的f2()改成虚函数，也将输出CC::f2(),这是满足动态绑定的。

### 知识点总结

1. **虚函数（`virtual`）和多态**
   - 使用 `virtual` 关键字声明的函数会在运行时绑定（即动态绑定）。如果基类指针指向派生类对象，通过该指针调用虚函数时会调用派生类的实现。
2. **静态绑定和动态绑定**
   - **静态绑定**：非虚函数在编译期绑定，直接调用指定类的函数。
   - **动态绑定**：虚函数在运行时绑定，根据指针指向的实际对象类型调用相应的函数。
3. **虚函数覆盖**
   - 当派生类重新定义虚函数时，覆盖了基类中的定义，基类指针指向派生类对象时会调用派生类的实现。

## 例题13

下列说明语句中正确的是：

A

int a,&ra=a,&&ref=ra;

B

int &refa[10];

C

int a,&ra=a,&*refp=&ra;

D

int*pi, *&pref=pi;

解答：

A：引用只能一层，不能多层引用。 

  B：不允许使用引用的数组。 

  C：指针是指向一个对象的，引用是别名，不是对象，所以不能定义指向引用的指针。 

  D：指针的引用，可以理解为如下： 

```cpp
int *pi;
int *(&ref) = pi;
//类比
int a;
int &ra = a;
```

### 知识点总结

各个选项涉及 C++ 中**引用（Reference）**、**指针（Pointer）** 以及它们的组合使用。让我们逐一分析每个选项。

1. **选项 A**: `int a, &ra=a, &&ref=ra;`
   - `int a`：定义一个 `int` 类型变量 `a`。
   - `&ra = a`：`ra` 是 `a` 的引用，语法正确。
   - `&&ref = ra`：这是一个错误，因为 `&&` 表示**右值引用（rvalue reference）**，而 `ra` 是左值引用，不能绑定到右值引用。
   - **错误的写法**。
2. **选项 B**: `int &refa[10];`
   - `refa` 被定义为一个引用数组，这是不允许的，因为在 C++ 中**不允许定义引用的数组**。
   - **错误的写法**。
3. **选项 C**: `int a, &ra = a, &*refp = &ra;`
   - `&ra = a`：`ra` 是 `a` 的引用，语法正确。
   - `&*refp = &ra`：`&*refp` 表示先解引用指针然后取引用，这在语法上无意义，编译会报错。
   - **错误的写法**。
4. **选项 D**: `int *pi, *&pref = pi;`
   - `int *pi`：定义一个 `int` 指针 `pi`。
   - `*&pref = pi`：`pref` 是 `pi` 的引用，即`pref` 是**指针的引用**。
   - 语法正确。
   - **正确的写法**。

**知识点总结**

1. **左值引用和右值引用**
   - **左值引用**（`&`）：可用于引用一个变量（左值），如`int &ref = a`。
   - **右值引用**（`&&`）：只能用于绑定临时对象或右值，不能绑定到左值。
2. **引用数组**
   - C++ 中不允许定义引用的数组，因为引用需要在定义时就绑定对象，数组无法满足这一点。
3. **指针引用**
   - 可以定义指针的引用，即**指向指针的引用**，例如 `int *&pref = pi`，其中 `pref` 是 `pi` 的引用。

## 例题14

若有声明：int a[10];，则对数组元素的正确引用是（）

A

a[10]；

B

a[3.5]

C

a(5)

D

a[10-10]

解答：

因为定义的数组包含10个元素，对数组元素引用的下标是从0~9。显然a[10]超出了数组的范围，A是错误的引用。因数组下标的数据类型必须是整型，所以B是错误的。数组引用应使用中括号，小括号是非法的，所以C也是错误的。故正确答案是D，即引用a[0]。

### 知识点总结

1. **数组的声明和下标范围**

- 声明 `int a[10];` 表示定义了一个包含 10 个整数元素的数组 `a`，元素的下标从 `0` 到 `9`。
- 因此，正确的访问范围是 `a[0]` 到 `a[9]`，不能使用 `a[10]`，否则会超出数组范围，导致**越界错误**。

2. **数组下标的数据类型**

- 数组下标应当是**整数**，且可以是一个表达式。表达式的结果会被取整。
- 例如：`a[10-10]` 的值是 `a[0]`，这属于合法的数组下标访问方式。
- 使用小数作为下标（如 `a[3.5]`）是非法的，因为数组下标必须是整数类型，编译器会报错。

3. **数组下标的语法**

- 数组下标必须使用**方括号 `[]`**，而不是圆括号 `()`。如 `a(5)` 是非法的，编译器会报错。
- 使用圆括号是函数调用的语法，而不是数组下标引用的方式。****

## 例题15

以下程序段中，不能正确赋字符串（编译时系统会提示错误）的是（ ）

A

char s[10]="abcdefg";

B

char t[]="abcdefg",*s=t;

C

char s[10];s="abcdefg";

D

char s[10];strcpy(s,"abcdefg");

解答：

答案选C

数组名s是常量指针，代表数组的首地址，它的值不能被改变。

### 知识点总结

指针常量：是相对于指针变量而言的，也就是指针值不能修改的指针；常量指针：是指向常量的指针的简称，可以修改指针值，不能修改指向的实体。

1. **字符数组的初始化**

- 在声明字符数组时，可以直接使用双引号内的字符串对其进行初始化。
- 例如，`char s[10] = "abcdefg";`，这种方式会在 `s` 数组中存储 `"abcdefg"` 和终止符 `\0`，合法且编译不会出错。

2. **字符指针的使用**

- 可以将字符数组的地址赋给字符指针。
- 例如，`char t[] = "abcdefg"; char *s = t;`，其中 `s` 指向字符数组 `t` 的首地址，这是合法的。

3. **字符数组和字符指针的区别**

- **字符数组**：如 `char s[10];` 表示分配一个固定大小的数组（10 个字符），在数组内可以存储字符数据。
- **字符指针**：`char *s` 只是一个指针，可以指向任意一个字符数组或字符串的起始地址。
- 字符数组一旦定义，变量名 `s` 表示数组的首地址，不允许通过直接赋值的方式改变地址（例如 `s = "abcdefg";` 试图将字符数组重新赋值为一个字符串常量，这是非法的，会导致编译错误）。

4. **`strcpy` 函数的使用**

- `strcpy` 是字符串复制函数，用于将字符串常量或字符数组的内容复制到目标字符数组中。
- 用法：`strcpy(destination, source);`，例如 `strcpy(s, "abcdefg");` 会将 `"abcdefg"` 复制到字符数组 `s` 中，合法且不会产生编译错误。

## 例题16

下列for循环的循环体执行次数为

```c++
for(int i=10, j=1; i=j=0; i++, j--)
```

A

0

B

1

C

无限

D

以上都不对

解答：

for循环的条件判断语句 i=j=0 是一个赋值表达式，它的结果是它左侧运算对象，类型为左侧运算对象的类型。  

这里该表达式的值为0，而for在初始化后即进入条件判断语句，此时的条件判断结果是0，故不再执行循环体，即循环体执行次数为0。

### 知识点总结

**1. `for` 循环的基本结构**

一个 `for` 循环的基本格式为：

```
for (初始化表达式; 循环条件; 迭代表达式) {
    循环体
}
```

- **初始化表达式**：在循环开始时执行一次，用于初始化变量。
- **循环条件**：每次循环开始前检查条件是否为真。如果为真，执行循环体；否则，退出循环。
- **迭代表达式**：每次循环体执行完后执行，用于更新循环变量。

**2. `for` 循环条件的评估**

在 `for` 循环中，条件判断表达式的结果会被转换为布尔值：

- **非零值**：表示条件为真，继续执行循环体。
- **零值**：表示条件为假，退出循环。

**3. 题目中的关键点分析**

分析题目中的代码：

```C++
for (int i = 10, j = 1; i = j = 0; i++, j--)
```

- **初始化部分**：`int i = 10, j = 1;` 初始化了 `i` 为 `10`，`j` 为 `1`。

- 循环条件：

  ```C++
  i = j = 0
  ```

  - 这里是一个**赋值表达式**，从右到左计算。
  - `j = 0` 将 `j` 的值设置为 `0`，然后返回 `0`，将结果赋值给 `i`，所以 `i` 也被设置为 `0`。
  - 整个条件 `i = j = 0` 的最终值是 `0`。
  - 由于条件为 `0`（即 `false`），循环不会执行。

- **迭代表达式**和**循环体**：由于循环条件为假，循环体和迭代表达式不会执行。

## 例题17

在下列描述中，正确的是（）

A

虚函数是没有实现的函数

B

纯虚函数是返回值等于0的函数

C

抽象类是只有纯虚函数的类

D

抽象类指针可以指向不同的派生类

解答：

A 纯虚函数才是在基类中没有实现的函数 （虚函数是在基类中实现了，但是在派生类中可能有不同版本的函数） 错 

B 纯虚函数是在基类中等于0的函数 错 

C 抽象类是含有纯虚函数的类 错 

D 是对的，这是C++多态的性质

### 知识点总结

**1. 虚函数（Virtual Function）**

- **虚函数**是一种在基类中定义并允许在派生类中重写的函数，目的是实现**多态**。通过基类指针调用派生类的重写函数，可以实现动态绑定。
- 虚函数通常在基类中实现，但允许在派生类中重写。

**2. 纯虚函数（Pure Virtual Function）**

- **纯虚函数**是在基类中声明、没有实现的虚函数，表示基类只定义接口，具体实现留给派生类。

- 纯虚函数的语法是在函数声明后添加 `= 0`，例如：

  ```C++
  virtual void functionName() = 0;
  ```

- **纯虚函数不返回任何值**。`= 0` 只是语法，用于声明该函数是纯虚函数，并非返回值为 0。

**3. 抽象类（Abstract Class）**

- 包含**至少一个纯虚函数**的类被称为**抽象类**。抽象类不能实例化，但可以用作接口，派生类必须实现所有纯虚函数才能实例化。
- 抽象类可以包含普通成员函数、虚函数、甚至实现代码，不必所有函数都是纯虚函数。

**4. 抽象类指针的多态性**

- 抽象类的指针或引用可以指向不同的派生类对象，实现**多态**。

- 例如：

  ```C++
  AbstractClass* ptr = new DerivedClass();
  ```

  此时 `ptr`可以指向派生自 `AbstractClass`的任何派生类。

## 例题18

有以下一段代码：

```c++
#include <iostream>
using namespace std;
class A {
public :
    void run(void) {
        cout << "run()" << endl;
    }
    void run(int a){
        cout << "run(A)" << endl;
    }
};
class B : public A {
public :
    void run(int a) {
        cout << "run(B)" << endl;
    }
};
int main(void)　{
    B b;
    b.run(0);　　//语句1
    b.A::run(1); //语句2
    b.run(); //语句3
    b.A::run(); //语句4
    return 0;
}
```

编译时会产生错误的语句有：

A

语句1

B

语句2

C

语句3

D

语句4

解答：

函数同名，参数不同，virtual可有可无-->隐藏 函数同名，参数相同，无virtual-->隐藏，有virtual-->覆盖  

答案选C

### 知识点总结

**函数重载（Function Overloading）**

- 在同一个类中，允许定义多个同名函数，但要求它们的**参数列表**不同（参数的类型、数量或顺序不同）。重载函数在编译时根据参数列表来确定调用哪个函数。

**函数隐藏（Function Hiding）**

- 当派生类中定义了与基类同名的成员函数时，即使参数列表不同，基类中的所有同名函数都会被隐藏，导致基类的这些函数在派生类中无法直接访问。
- 例如，在类 `B` 中定义了 `void run(int a)`，这会隐藏基类 `A` 中的所有 `run` 函数。
- 如果希望访问被隐藏的基类函数，需要显式使用作用域操作符 `A::` 来调用基类中的 `run` 函数。

**基类成员函数的访问**

- 派生类对象可以通过**作用域解析符（`::`）**显式调用被隐藏的基类成员函数，例如 `b.A::run(1);`。
- 在派生类中，当函数被隐藏时，即使基类中存在函数重载，也无法直接调用，除非显式使用 `类名::函数名` 的方式调用基类的函数。

## 例题19

*p++ 自增 p 还是 p 所指向的变量?

A.自增 p

B.自增 p 所指向的变量

C.和机器相关

解答：

后缀++ 和-- 操作符本质上比前缀一目操作的优先级高, 因此`*p++ `和`*(p++) `等价, 它自增p 并返回p 自增之前所指向的值。 要自增p 指向的值, 使用`(*p)++`, 如果副作用的顺序无关紧要也可以使用`++*p`。

### 知识点总结

后缀++ 和-- 操作符本质上比前缀一目操作的优先级高

## 例题20

下面程序中， 输出是什么？

```c++
int fun(int x){
    int count = 0;
    while(x){
        count++;
        x = x &(x-1);
    }
    return count;
}
int main(){
    cout << "fun(2015)=" << fun(2015)<<endl;
}
```

A.fun(2015)=11

B.fun(2015)=10

C.fun(2015)=9

D.fun(2015)=8

解答：

本题是统计一个数有多少个1的，2015=11111011111共10个1.

### 知识点总结

**按位与（&）**：对应位都为 1，结果为 1；否则为 0。

**按位或（|）**：只要有一位为 1，结果为 1；否则为 0。

**按位异或（^）**：相同为 0，不同为 1。

**按位取反（~）**：将每个位翻转，0 变 1，1 变 0。

**左移（<<）**：将每个位向左移动指定的位数，右边补 0。左移一位相当于乘 2。

**右移（>>）**：将每个位向右移动指定的位数，左边补符号位（算术右移）或 0（逻辑右移）。

## 例题21

下列字符串可以用作C++标识符的是：

A._123

B.2009var

C.goto

D.test - 2009

解答：

  标识符 

  标识符用来表示函数、类型及变量的名称，是字母、下划线和数字的排列。 

  1、必须用字母或下划线开头。 

  2、只能是字母、下划线、数字的组合，不能出现其他符号。 

  2、大小写的含义是不同的。 

  3、标识符的名称不能是C语言中的关键字，关键字是具有特定含义的标识符 

### 知识点总结

**C++ 标识符命名规则**

1. **只能包含字母（大小写）、数字和下划线**。
2. **必须以字母或下划线开头**，不能以数字开头。
3. **不能使用 C++ 关键字**，因为关键字有特定含义。
4. **区分大小写**，因此 `Variable` 和 `variable` 是不同的标识符。

## 例题22

下列程序段执行后，输出d的值为()

```c++
int main()
{
   int a=1,b=0,c=-1,d=0;
   d=++a||++b&&++c;
   cout<<d<<endl;
   return 0;
}
```

A.1

B.2

C.3

D.0

解答：

运算符优先级：&&>||>=

所以先计算++b&&++c,++c为0，所以整体是false=0，再计算++a||0，++a为true，所以整体是true=1，所以d=1

### 知识点总结

**短路求值**：

- `||`（逻辑或）：当左侧表达式为 `true` 时，整个表达式立即为 `true`，右侧表达式不会被求值。
- `&&`（逻辑与）：当左侧表达式为 `false` 时，整个表达式立即为 `false`，右侧表达式不会被求值。

**前置递增运算符**：

- `++a` 会先将 `a` 加 1，然后返回新的值。
- 表达式中 `++a || ++b && ++c` 的 `||` 优先级低于 `&&`，因此先计算 `++b && ++c` 的结果，再将结果用于 `++a || (...)`。

## 例题23

要求打开文件D:\file.dat，并能够写入数据，正确的语句是（）？

A.ifstream infile("D:\\file.dat", ios::in );

B.ifstream infile("D:\\file.dat", ios::out );

C.ofstream outfile("D:\\file.dat", ios::in );

D.fstream infile("D:\\file.dat", ios::in|ios::out );

解答:

A.选项是，从文件输入到内存中，也就是读，所以实现不了“**写入数据**” 

C.选项最后应该是 ios::out 

选D

### 知识点总结

**`ifstream`**：只读文件流，用于文件读取。常用模式：`ios::in`

**`ofstream`**：只写文件流，用于文件写入。常用模式：`ios::out`

**`fstream`**：读写文件流，用于文件的读写。常用模式组合：`ios::in | ios::out`

## 例题24

从本质上看，引用是被应用变量的（    ）

A.拷贝

B.别名

C.复制

D.克隆

解答：

从本质上看引用是指向常量的指针，不过我们在平时使用的时候只需要把它看做是一个变量的别名就好了。这样可以让我们从复杂的环境中解放出来，不必在意具体实现细节，从而可以容易的解决问题。

### 知识点总结

在C++中，**引用**是一个已经存在变量的别名，通过引用可以直接操作原变量的值，而无需复制。以下是对引用的本质和使用的详细总结：

1. **引用的本质**：
   - 引用是**变量的别名**，它和原变量指向同一块内存区域。引用一旦与某个变量绑定后，就无法更改绑定的对象，引用名和变量名可以互换使用。
   - 由于引用指向原变量，操作引用等同于直接操作该变量。
2. **引用的特性**：
   - 引用必须在定义时进行初始化，且不能重新绑定。
   - 引用的操作不会产生额外的内存开销或副本，因此引用的效率比传值方式更高。
3. **与指针的区别**：
   - 引用在操作时不需要使用特殊符号（如 `*`），更简洁和安全。
   - 引用在初始化后不能指向其他变量，而指针可以更改指向的地址。
4. **引用的应用场景**：
   - **函数参数**：通过引用传递参数，避免了拷贝，提高效率。
   - **返回值优化**：返回引用可以避免创建临时对象，用于性能优化。
5. **避免的误区**：
   - 引用不是原变量的拷贝或克隆，引用并不会生成新的数据对象，只是提供了原变量的另一个名称。

## 例题25

设 a,b,c 为整型变量，执行下面语句

```c++
a = 2;
b = 9;
a++;
c = --b;
a += b - c;
```

后 a 的值为（ ）

A.7

B.4

C.3

D.2

解答：

下列是每一步种数据的变化情况

a = 2;

b = 9;      //a = 2, b = 9
a++;      // a = 3, b = 9
c = --b    // b = 8, c = 8
a += b - c  //a += (b-c) => a += 0 => a = 3，因此正确答案是C

### 知识点总结

**自增、自减运算符**

- `a++` 表示**后置自增**，即在表达式中使用当前值，之后再将 `a` 增加 1。
- `--b` 表示**前置自减**，即先将 `b` 减 1，然后使用新值。

**复合赋值运算符 `+=`**

- `a += b - c` 相当于 `a = a + (b - c)`，即先计算 `b - c` 的值，再将结果加到 `a` 上。

**表达式的计算顺序**

- 遇到 `--b` 这样的前置运算符时，变量的值会在当前表达式中先被改变，而 `a++` 的后置运算符则会在表达式计算后才进行改变。

## 例题26

以下程序的输出结果（32位机器上）是（）

```c++
int main(){
    char *p = "abcdefgh", *r;
    long *q;
    q = (long*)p;
    q++;
    r = (char*)q;
    printf("%s\n", r);
}
```

A.abcd

B.bcde

C.cdef

D.efgh

解答：

char* p = "abcdefgh"，每个字符占1个字节，那么总共是8个字节，此时p指向'a'。如果是p++，那么p将指向'b'。打印p会得到"bcdefgh"。  

long* q = (long*)p 将p强制转换为long*类型，也就是用long类型去解释存储了"abcdefgh"的这一段内存，此时q指向'a'，由于long类型是4个字节，那么q++移动4个字节，q将指向'e'，打印q将得到"efgh"。

### 知识点总结

**指针类型转换**

- 将指针转换为不同类型的指针后，指针的偏移量和步长会受到新类型大小的影响。

**指针的移动**

- `q++` 表示 `q` 向后移动一个 `long`（即 4 字节），而不是一个 `char`（1 字节）。在 32 位机器上，`long` 占用 4 字节，因而 `q++` 移动了 4 个字节的位置。

**格式化输出**

- 使用 `"%s"` 输出时，指针会从当前位置开始输出字符串，直到遇到空字符 `\0` 为止。

## 例题27

已知 int 占 4 个字节，bool 占 1 个字节。对于下面代码：

```c++
#include <iostream>
using namespace std;
 
int main(int argc, char** argv) {
    unsigned int value = 1024;
    bool condition = *((bool*)(&value));
    if (condition) value += 1; condition = *((bool*)(&value));
    if (condition) value += 1; condition = *((bool*)(&value));
}
```

value, condition 的结果为（）

A.1026, 1

B.1025, 0

C.1025, 1

D.1024, 0

解答：

value 的十六进制表示为 0x00000400，将其转化为 bool 类型，在大端的情况下取左边的两个 0 赋给 condition，在小段的情况下取右边的两个 0 赋值给 condition，因此 condition 为 false。所以两个 if 条件都不会执行。value, condition 最终为 1024 和 0。D 选项正确。

### 知识点总结

**指针类型转换**

- 在 C++ 中，通过类型转换可以改变指针的解引用类型，但不会改变指向的内存内容。在本例中，将 `unsigned int*` 转换为 `bool*`，访问的是 `unsigned int` 的最低字节。

**布尔值判断**

- 当使用 `bool` 类型指针访问 `int` 类型变量的最低位时，如果最低位的字节非零，则 `bool` 为 `true`；若最低位字节为零，则 `bool` 为 `false`。

**条件判断和位操作的结合**

- 在某些情况下，使用最低位进行条件判断是一种常见的位操作方法，用于快速判断奇偶性或其他条件。

## 例题28

关于C++中的友元函数说法正确的是（    ）

A.友元函数只能访问所在类的保护成员和公有成员，不能访问私有成员

B.友元函数是不能被继承的

C.友元函数没有this指针

D.友元函数破环了继承性机制

解答：

友元函数是不能被继承的，可理解为：你父亲的朋友不一定是你自己的朋友 

this指针是指向当前对象的，可以访问当前对象的所有成员，而友元函数是非成员函数，没有this指针 

友元函数并没有破坏继承性机制，因为友元函数是非成员函数，并不会被继承，继承只是继承的成员函数及变量

### 知识点总结

**友元函数的定义**

- 友元函数（Friend Function）是被某个类声明为“朋友”的函数。它可以访问该类的**私有成员**和**保护成员**，使其能够操作类的内部数据，而不受访问控制的限制。

**访问权限**

- 友元函数**可以访问私有成员**、保护成员和公有成员。选项 A 错误，因为友元函数不仅可以访问保护成员和公有成员，还可以访问私有成员。

**没有 `this` 指针**

- 友元函数**没有 `this` 指针**，因为它不是类的成员函数。`this` 指针通常用于类的成员函数中，指向调用该成员函数的对象自身。友元函数没有对象归属，因此不需要 `this` 指针。

**不属于继承关系**

- 友元关系不受继承的影响，友元函数不会被继承到子类中。选项 B 虽然描述了友元函数不能被继承的事实，但这是因为友元关系并不具备继承性，并非友元函数本身的特性。
- 选项 D 错误，友元机制本身并不影响继承性机制，它只提供了一种额外的访问权限。

**友元函数的应用**

- 友元函数经常用于需要多个类之间进行紧密协作的场景。友元函数能更自由地访问不同对象的私有数据，从而实现更复杂的类间操作。

## 例题29

二进制数据文件流fdat读指针移到文件头的语句是（）？

A

fdat.seekg( 0, ios::beg);

B

fdat.tellg( 0, ios::beg );

C

fdat.seekp( 0, ios::beg);

D

fdat.tellp( 0, ios::beg );

解答：

对输入流操作：seekg（）与tellg（） 对输出流操作：seekp（）与tellp（） seekg（）是对输入文件定位，它有两个参数：第一个参数是偏移量，第二个参数是基地址。 对于第一个参数，可以是正负数值，正的表示向后偏移，负的表示向前偏移。而第二个参数可以是： ios：：beg：表示输入流的开始位置 ios：：cur：表示输入流的当前位置 ios：：end：表示输入流的结束位置 tellg（）函数不需要带参数，它返回当前定位指针的位置，也代表着输入流的大小。

### 知识点总结

**文件指针（读指针和写指针）**
在文件流操作中，C++ 提供了两种文件指针：

- **读指针（get pointer）**：用于定位文件读取位置。`seekg` 和 `tellg` 函数用于操作读指针。
- **写指针（put pointer）**：用于定位文件写入位置。`seekp` 和 `tellp` 函数用于操作写指针。

**`seekg` 和 `seekp` 函数**

- `seekg`：用于移动读指针位置。

- `seekp`：用于移动写指针位置。

- 这两个函数的格式为 

  ```
  seekg(offset, direction)
  ```

   或 

  ```
  seekp(offset, direction)
  ```

  ，其中：

  - `offset`：偏移量，以字节为单位。

  - ```
    direction
    ```

    ：指针移动的参考位置，可以是以下值：

    - `ios::beg`：文件的开头。
    - `ios::cur`：当前位置。
    - `ios::end`：文件的末尾。

**`tellg` 和 `tellp` 函数**

- `tellg`：返回当前读指针的位置。
- `tellp`：返回当前写指针的位置。
- 这些函数不接受任何参数。

## 例题30

下列对描述正确的是（）

A.包含虚函数的类有this指针

B.包含虚函数的类没有this指针

C.包含虚函数的类不能被继承

D.包含虚函数的类能被继承

解答：

纯虚函数：只提供一个接口，具体实现方法需要派生类自己去实现 

虚函数：提供接口，并提供默认的实现方法，派生类也可以根据自己需求去重载 

非虚函数：提供接口，强制实现方法

### 知识点总结

**虚函数（Virtual Function）**

- 在 C++ 中，虚函数是一种通过在基类中使用 `virtual` 关键字定义的函数，允许派生类重写该函数。
- 虚函数通常用于实现**多态**，即通过基类指针或引用调用派生类中重写的函数。
- 虚函数是动态绑定的，这意味着在运行时，根据实际的对象类型来决定调用哪个函数实现。

**`this` 指针**

- 在 C++ 中，`this` 指针是一个隐式指针，指向当前对象。
- 所有非静态成员函数都有 `this` 指针，无论类中是否包含虚函数。因此，**包含虚函数的类也有 `this` 指针**。
- `this` 指针在每个非静态成员函数中隐式传递，以便访问当前对象的数据成员和其他成员函数。

**继承和虚函数**

- 包含虚函数的类可以被继承，这是 C++ 中实现多态性的基础。
- 当派生类继承自包含虚函数的基类时，可以重写（覆盖）这些虚函数，以实现多态行为。
- 例如，基类可以定义一个虚函数 `print()`，派生类可以重写 `print()`，这样在运行时可以通过基类指针调用派生类的 `print()` 方法。

## 例题31

请指出下列代表有几处错误？

```c++
#include <stdio.h>
class A
{
    public:
      virtual void f(){}
    public:
       A()
       {
           f();
       }
};
 
class B1:public A()
{
    private:
        char *_s;
    public:
        B1()
        {
            _s=new char[1024];
        }
    private:
        void f()
        {
            delete _s[];
            _s=NULL;
        }
}
 
class B2:public A
{
    private:
        int * _m;
    public:
        B2()
        {
            _m=new int(2016);
        }
    private:
        virtual void f()
        {
            delete _m;
            _m=NULL;
        }
}
int main()
{
    A *a1=new B();
    A *a2=new C;
    delete a1;
    delete a2;
    return 0;
}
```

A.3

B.4

C.5

D.6

解答：

共6处错误： 

12. `class B1:public A() -> class B1:public A` 

24. `delete _s[]; -> delete []_s;` 

27. `} -> }; `

43. `} -> };` 

46. `A*a1=new B(); -> A*a1=new B1();` 

47. `A*a2=new C; -> A*a2=new B2;` 

### 知识点总结

1. **继承的基本语法**：
   - 使用 `class Derived : public Base` 定义继承关系，不需要在基类后面添加 `()`。
2. **虚函数和构造函数的关系**：
   - 构造函数内部调用虚函数会导致编译器调用基类版本的虚函数（此代码中不影响编译但影响预期行为）。
3. **动态内存管理**：
   - 对数组指针使用 `delete[]`，普通指针使用 `delete`。这里 `delete _s[];` 是错误的，应为 `delete[] _s;`。
4. **构造函数与析构函数的实现**：
   - 在构造函数中分配的动态内存需要在析构函数中释放，但此代码未实现析构函数，易导致内存泄漏。
5. **继承关系中使用虚析构函数**：
   - 当基类指针指向派生类对象时，为了确保正确释放对象，应在基类中定义虚析构函数 `virtual ~A(){}`。
6. **分号缺失的错误**：
   - 类定义结束后需要分号，缺少会导致编译错误。

## 例题32

有以下一段代码

```c++
class A
{
public:
    A() {}
    ~A() {}
};
class B : public A
{
public:
    B() {}
    ~B() {}
public:
    int a;
};
```

若：x=sizeof(A),y=sizeof(B)，请问x，y的值分别是多少？

A

x=0，y=4

B

x=1，y=4

C

x=1，y=5

D

x=4，y=8

解答：

空类中编译器插入一个char类型，用来标识这个class不同实体在内存中配置独一无二地址，故空类大小1字节

### 知识点总结

**类的最小内存占用**：

- 即使一个类没有成员变量，编译器会为类分配至少 1 字节的空间，以便区分不同的实例。这就是为什么 `sizeof(A) = 1`。

**继承关系中的内存布局**：

- 当一个类继承另一个类时，子类会继承基类的大小，并且在其基础上增加自己成员变量的大小。因此，`sizeof(B) = sizeof(A) + sizeof(B 的成员变量)`。

**数据成员的大小和内存对齐**：

- `int` 通常占用 4 字节，`sizeof(B)` 会包含父类的 1 字节大小和子类 `int a` 的 4 字节大小，从而得到 5 字节。

**内存对齐的影响**：

- 在这个示例中，内存对齐没有影响结果。但在实际应用中，编译器可能会根据对齐要求调整类的大小。

## 例题33

下列关于多态性说法不正确的是：

A

重载函数名相同，但是参数列表个数和顺序，参数类型，以及返回类型一定不同

B

重载 overload 和 重写 override 是一个意思

C

多态行有静态和动态多态两种

D

c++中 final 关键字表示函数不能再次被override

解答：

a选项
 C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 顺序)必须不同
 b选项
 1.函数的重载
 C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能。这就是重载函数。重载函数常用来实现功能类似而所处理的数据类型不同的问题。不能只有函数返回值类型不同。
 两个重载函数必须在下列一个或两个方面有所区别：
 1、函数的参数个数不同。
 2、函数的参数类型不同或者参数类型顺序不同，
 C++的这种编程机制给编程者极大的方便，不需要为功能相似、参数不同的函数选用不同的函数名，也增强了程序的可读性。
 2.函数的重写
 多态中提到的，一般父类函数中有虚函数，虚函数包含虚函数指针，指向虚函数表。在子类继承父类时，会一同把虚函数继承下来，同时也会把虚函数指针以及指针指向的虚函数表继承下来，如果在子类中对父类中的虚函数重写一遍，函数表中的内容就会被子类覆盖。
 重写只有函数体内的语句不同，其他都一样。
 c选项
 模板和虚函数都能实现多态，那么这两者到底有什么区别呢？模板实现属于静态多态，而虚函数实现属于动态多态，静态多态是在编译时完成的，动态多态是在程序运行时完成的。
 d选项
 final用来修饰类，让该类不能被继承，理解：使得该类终结！
 final用来修饰类的虚函数，使得该虚函数在子类中，不能被重写，理解：使得该功能终结！

### 知识点总结

**重载（Overloading）**：

- 重载是指在同一作用域中定义多个函数名相同但参数列表不同的函数。
- 返回类型不影响重载，但参数的类型、个数或顺序必须不同。

**重写（Override）**：

- 重写是指在派生类中对基类的虚函数重新定义，参数列表和返回类型必须与基类虚函数一致。
- 重写是实现动态多态的重要手段。

**多态（Polymorphism）**：

- 多态性分为静态多态和动态多态。
  - **静态多态**通过函数重载和运算符重载实现，编译期确定。
  - **动态多态**通过虚函数和基类指针或引用实现，运行时确定。

**`final` 关键字**：

- `final` 用于类或函数，表示该类不能被继承，或该函数不能被重写（Override）。
- 用法示例：`void func() final;` 表示该函数不可被重写。

## 例题34

作用域运算符“::”的功能是________________

A.标识作用域的级别的

B.指出作用域的范围的   

C.给定作用域的大小的

D.标识成员是属于哪个类的

解答：

C/C++中，::是运算符中等级最高的，它分为三种：全局作用域符，类作用域符，命名空间作用域符

### 知识点总结

**全局作用域**：

- `::` 可以用来访问全局变量或函数。例如，当局部变量与全局变量重名时，可以通过 `::` 访问全局变量。

**命名空间作用域**：

- 在 C++ 中，`::` 可以用来访问某个命名空间内的成员（如变量、函数等），以避免命名冲突。

**类的作用域**：

- 作用域运算符可以用来定义类的成员函数，特别是在类的定义之外实现成员函数时。例如：

**静态成员的访问**：

- 作用域运算符也可以用于访问类的静态成员，通常是在类外部进行静态成员访问时使用。

## 例题35

```c++
#include <iostream>
using namespace std;

int WhoAmI(int num1, int num2)
{
    if (num2 == 0)
        return num1;

    int num = num1 ^ num2;
    int carry = (num1 & num2) << 1;

    return WhoAmI(num, carry);
}

int _tmain(int argc, _TCHAR* argv[])
{
    cout << WhoAmI(5, 6) << endl;
    return 0;
}
```

A.1

B.11

C.-1

D.30

解答：

B 

该函数的作用是将两个数相加 

num1^num2为两个数相加不带进位的结果 

(num1&num2)<<1为两个数相加的进位值 

递归调用将进位值加到相加结果上，不断递归知道进位为0为止，结果为num1与num2相加的值

### 知识点总结

1. **位运算实现加法**

- 这段代码的核心功能是通过位运算实现两个整数的加法，而不使用加法运算符 `+`。

- 具体实现原理：

  - **异或运算 `^`**：异或运算可以模拟加法但不包括进位。对于每一位，若两个位不同，则结果为1（即0^1=1, 1^0=1），相同则为0（即0^0=0, 1^1=0）。
  - **按位与（AND）：`&`**
    - 按位与运算符的作用是将两个数的二进制位逐位进行“与”操作。只有当两个对应位都是1时，结果才为1，否则结果为0。
  - **与运算加左移 `(num1 & num2) << 1`**：与运算`&`可以模拟进位（只有两个位都是1时结果为1）。将进位的结果左移一位，以便在下一次计算中添加到相应的位置。
  - **按位或（OR）：`|`**
    - 按位或运算符将两个数的二进制位逐位进行“或”操作。只要有一个位为1，结果就为1，只有两个对应位都是0时结果才为0。

  **示例**：

  - 假设要计算 5 + 6（二进制分别为0101和0110）：
    - 第一步：`num1 ^ num2` 计算不考虑进位的部分，即 `0101 ^ 0110 = 0011`。
    - 第二步：`(num1 & num2) << 1` 计算进位部分，即 `(0101 & 0110) << 1 = 0100 << 1 = 1000`。
    - 递归地将不考虑进位的部分和进位部分相加，最终得到 `1011`，即十进制的 `11`。

2. **递归实现加法**

- `WhoAmI` 函数通过递归实现加法。当进位 `num2` 为 0 时，递归终止，返回结果 `num1`。
- 每次递归调用中，函数将上一次的加法结果分为两部分：
  - `num`：异或计算结果，即未包含进位的部分。
  - `carry`：与运算的结果左移一位，表示进位。
- 递归的本质是逐步消除进位，直到进位为0，表示加法完成。

3. **递归的终止条件**

- 递归终止条件：

  ```
  if (num2 == 0) return num1;
  ```

  - 当 `num2` 为 0 时，表示没有进位，整个加法过程完成，可以返回结果。
  - 递归终止条件避免了无限递归，否则程序会因栈溢出而崩溃。

4. **递归的栈机制**

- 每次调用 `WhoAmI` 函数时，都会在栈上分配一个新的函数调用帧，包含局部变量 `num` 和 `carry`。
- 递归调用的次数与进位的产生次数有关，最差情况下递归的深度取决于输入整数的位数（大约为`log2(n)`）。
- 理解递归过程有助于掌握栈帧的调用和释放顺序。

5. **使用位运算优化代码**

- 在某些低级编程环境（例如嵌入式系统中），直接使用位运算实现加法可以节省时间和空间。
- 位运算比普通的算术运算更快，因为位运算直接在二进制位上操作，无需调用额外的加法指令。

## 例题36

以下语句哪个判断是错误的?

```c++
int& func_int_r(void);
int&& func_int_rr(void);
int func_int(void);
 
const int&& func_cint_rr(void);
const int func_cint(void);
 
int x=0;
 
decltype(func_int_r())    a1=x; //1.判断a1是int&类型
decltype(func_int_rr())   b1=0; //2.判断b1是int&&类型
decltype(func_int())        c1=0; //3.判断c1是int类型
 
decltype(func_cint_rr())  b2=x; //4.判断b2是const int&&类型
decltype(func_cint())         c2=x; //5.判断c2是const int类型
```

A.1

B.2

C.3

D.4

E.5

解答：

deltype(func_cint)得到是函数类型，不是函数返回类型。函数类型，函数指针。太偏了

### 知识点总结

1. **`decltype` 关键字**：
   - `decltype` 用于推导表达式的类型，不执行表达式，只是获取其类型信息。
   - `decltype` 可以返回左值引用、右值引用和普通类型，具体取决于表达式的类型。
2. **左值引用和右值引用**：
   - 左值引用（`&`）可以绑定到左值。
   - 右值引用（`&&`）只能绑定到右值（如临时对象、字面值等），不能绑定到左值（如变量）。
3. **返回类型的推导**：
   - 如果一个函数返回 `int&`，则使用 `decltype(func())` 推导出的类型也是 `int&`。
   - 同样，如果函数返回 `int&&`，则 `decltype(func())` 推导的类型为 `int&&`。
4. **const右值引用（`const int&&`）的行为**：
   - `const int&&` 表示一个不可修改的右值引用，通常用于绑定到临时对象或字面值。
   - `const int&&` 不能绑定到非临时变量（左值），例如普通的 `int` 变量。

## 例题37

已有定义：char a[]="xyz",b[]={'x','y','z'};，以下叙述中正确的是 （）（长度使用sizeof比较)

A.数组a和b的长度相同

B.a数组长度小于b数组长度

C.a数组长度大于b数组长度

D.上述说法都不对

解答：

sizeof和strlen的区别是： 

sizeof的大小在你定义数据类型的时候就决定了；而strlen是求字符串的长度，根据你所输入的内容决定，strlen以\0为结束标志比如"xyz",实际上隐藏了\0，那么strlen可以读取，strlen只能读取有\0的字符串，如果没有就不行，'x','y','z'，strlen是不能读取的，必须要加上'\0'例如：{‘’x','y','z','\0'} 

本题需要特别注意的是： 本题与strlen一点关系都没有 

a[],b[]这两个数组它的大括号里面并没有指明这个数组的大小。那么sizeof在计算的时候就会计算其中的实际字符内容的长度（包括'\0'），如果是字符串“xyz”，在c语言中字符串是以'\0'结尾的，sizeof就会将\0计算进去，所以长度为4，而‘x’,'y','z'，是字符，没有\0作为末尾，所以它的长度是3，因此本题选C。

### 知识点总结

1. **字符串字面量与字符数组**：
   - 在C语言中，当定义一个字符串字面量时，例如 `char a[] = "xyz";`，编译器会自动在字符串末尾添加一个空字符 `\0`。
   - 因此，字符串的实际长度比字面量中的字符数多1，用于存储终止符。
2. **字符数组的初始化**：
   - 使用 `char b[] = {'x', 'y', 'z'};` 定义的字符数组没有空字符 `\0`，因此它只是一个简单的字符数组，不会自动在末尾添加终止符。
3. **`sizeof` 运算符**：
   - `sizeof` 返回数组的实际存储字节数。
   - 对于 `char` 数组，`sizeof` 的结果就是字符的数量（包括空字符 `\0`），例如 `sizeof(a)` 返回 4，`sizeof(b)` 返回 3。
4. **字符串的长度与数组长度的区别**：
   - 使用字符串字面量定义的数组会自动包含一个额外的字符 `\0`，使数组长度大于字符内容的实际长度。
   - 如果需要判断字符串内容的长度，可以使用 `strlen()` 函数，它不会计入空字符 `\0`；而 `sizeof` 会包括 `\0`。

## 例题38

通过一个对象调用虚函数时，C++系统对该调用采用(  )。

A.动态联编

B.静态联编

C.不确定是哪种联编

D.函数重载

解答：

**静态联编** 通过对象名调用虚函数，在编译阶段就能确定调用的是哪一个类的虚函数 

**动态联编** 通过基类指针调用，在编译阶段无法通过语句本身来确定调用哪一个类的虚函数，只有在运行时指向一个对象后，才能确定调用时哪个类的虚函数

如果不是通过指针调用虚函数的话，也不是动态联编

### 知识点总结

1. **虚函数和动态联编**：
   - 虚函数使得C++支持运行时多态性，即在运行时确定具体调用的函数。
   - 通过基类指针或引用调用虚函数时，系统会根据对象的实际类型在运行时动态选择函数。
2. **虚函数表（V-Table）**：
   - 编译器为每个含有虚函数的类创建一个虚函数表，表中存储了该类的虚函数指针。
   - 虚函数表指针（V-Table Pointer）是指向该表的指针，每个对象实例都会包含一个指向其类的虚函数表的指针。
3. **静态联编与动态联编的区别**：
   - 静态联编在编译时确定调用的函数，用于普通成员函数和非虚函数。
   - 动态联编在运行时确定调用的函数，用于虚函数。
4. **多态性**：
   - 虚函数与动态联编使得C++的继承结构支持多态性，可以通过基类指针或引用调用派生类实现的虚函数。
5. **注意事项**：
   - 虚函数只能在使用指针或引用调用时才会触发动态联编。如果直接通过对象调用，仍然会采用静态联编。
   - 使用虚函数会增加一定的内存和运行时开销（因为需要维护虚函数表和虚函数表指针），但这是实现多态性的必要代价。

## 例题39

类静态数据成员必须在类外声明和初始化。

A.True

B.False

解答：

**在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。**

**class A**

**{**  

​    **private:**

​    **static int count ; // 类内声明**

**};**

**int A::count = 0 ; // 类外初始化，不必再加static关键字**

**因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。**

**能在类中初始化的成员只有一种，那就是静态常量成员。**

**此外，还需要注意的是声明和定义的区别：**

**①变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。**

**②变量声明：用于向程序表明变量的类型和名字。**

**在该题目中的定义指的是分配空间。**

### 知识点总结

在C++中，**类的静态数据成员必须在类外定义**，但**并不要求必须在类外初始化**。因此，"类静态数据成员必须在类外声明和初始化"这一说法是不准确的，准确的说法是"类静态数据成员必须在类外定义"。

静态数据成员的特点如下：

1. **静态数据成员的声明和定义**：
   - 静态数据成员在类内声明，但在类外定义。
   - 定义的格式为：`数据类型 类名::静态成员名 = 初始值;`
   - 定义时可以选择性地初始化静态数据成员。
2. **静态数据成员的初始化**：
   - 静态数据成员可以在类外定义时初始化。
   - 对于简单的静态常量（如整型或枚举类型的`const static`），可以直接在类内部初始化。

## 例题40

2个同名成员函数，可以重载的是（）?

A.int A::f() 和double A::f()

B.void A::f(int) 和void A::f(short)

C.void A::f() 和void A::f() const

D.void A::f(int) 和void A::f(const int)

E.const int A::f() 和int A::f()

解答：

1.  A.返回值不能区分重载函数，只有形参的个数、类型或者顺序可以       
2. ​    B.int和short不一样，所以可以重载       
3. ​    C.const放在函数后面是指这个成员函数为常成员函数，不能修改类里的成员变量，可以起到重载的作用。       
4. ​    D.int和const int都是int类型，区别是后者不能对形参进行修改而已，这样写不可以重载，编译会报错。       
5. ​    E.函数前面加const也起不来重载的作用，其作用在于声明返回的值为cosnt不可修改，绝大多数情况下没啥意义。      

PS：**声明一个成员函数的时候用**const关键字是用来说明这个函数是**"**只读(read-only)"**函数，也就是说明这个函数不会修改任何数据成员**(object)。**为了声明一个**const**成员函数，**把**const**关键字放在函数括号的后面。声明和定义的时候都应该放**const**关键字。  

**任何不会修改数据成员的函数都应该声明为**const**类型，如果在编写**const**成员函数时，不慎修改了数据成员，或者调用了其它非**const**成员函数，编译器将指出错误，这可以提高程序的健壮性。**  

### 知识点总结

1. **函数重载的条件**：
   - 函数名相同，参数列表必须不同。
   - 参数列表的不同可以体现在参数的类型、参数的数量或参数的顺序上。
   - 返回类型不同不能实现重载，仅靠返回类型不同的函数会被视为同一签名，导致编译错误。
2. **`const` 成员函数重载**：
   - 成员函数可以通过 `const` 限定符进行重载，例如 `void f()` 和 `void f() const` 是两个不同的函数。
   - 非 `const` 成员函数可以修改对象的状态，而 `const` 成员函数不能修改对象状态，因此可以被编译器区分开。
3. **`const` 参数与非 `const` 参数**：
   - 如果参数是按值传递（如 `int` 和 `const int`），那么 `const` 限定符不会影响参数的类型，编译器会认为它们是相同的类型。
   - 按值传递的 `const` 参数和非 `const` 参数不能构成重载。
4. **重载时返回类型无关**：
   - C++中函数重载与返回类型无关，即函数重载不能仅仅依赖返回类型的不同。即使返回类型不同，编译器仍会认为函数签名相同而导致重载失败。

## 例题41

下面选项中关于编译预处理的叙述正确的是（）

A.预处理命令行必须使用分号结尾

B.凡是以#号开头的行，都被称为编译预处理命令行

C.预处理命令行不能出现在程序的最后一行

D.预处理命令行的作用域是到最近的函数结束处

解答：
本题考查预编译的预编译处理命令行，预处理命令行不能以分号结尾，所以 A 选项错误，预处理命令行可以出现在程序的最后一行，预处理命令行作用域是整个文件。

### 知识点补充

- **文件包含**：`#include <file>` 或 `#include "file"` 用于包含其他文件的内容。
- **宏定义**：`#define` 用于定义宏，宏名称在定义后可以在文件中任何地方使用，直到遇到 `#undef`。
- **条件编译**：`#ifdef`、`#ifndef`、`#endif` 等指令用于根据条件来编译代码的某些部分。

## 例题42

```c
class P
{
private:
    int ival;
public:
    P();
    ~P();
    int GetVal(){
        return ival;
    };
    virtual int SetVal(int val)
    {
        ival=val;
    };
};
```

在32位编译器下sizof(P)为()

A.4

B.8

C.12

D.16

解答：

1.类的大小为类的非静态成员数据的类型大小之和，也就是说静态成员数据不作考虑。 2.普通成员函数与sizeof无关。 3.虚函数由于要维护在虚函数表，所以要占据一个指针大小，也就是4字节。 4.类的总大小也遵守类似class字节对齐的，调整规则。  本题中,int ival占4个字节，同时virtualintSetVal(intval)占用4个字节，一共是占用8个字节，选B

### 知识点总结

**成员变量的大小**：

- 类 `P` 有一个私有成员变量 `int ival`，在 32 位编译器下，`int` 类型的大小为 4 字节。

**虚函数和虚函数表**：

- 类 `P` 中声明了一个虚函数 `SetVal`，这意味着编译器会为 `P` 类分配一个 **虚函数表指针（vptr）**。
- 虚函数表指针的大小在 32 位编译器下通常为 4 字节（即一个指针大小）。
- `vptr` 指针会增加类的内存占用，因此该类的总大小增加了 4 字节。

1. **对齐规则**：
   - 结构体或类的大小通常遵循内存对齐规则，通常以最宽的成员变量或指针的大小作为对齐单位。
   - 在 32 位系统中，`int` 和 `vptr` 都是 4 字节，因此总大小也遵循 4 字节对齐规则。
2. **大小计算**：
   - 成员变量 `ival` 占用 4 字节。
   - 虚函数表指针 `vptr` 占用 4 字节。
   - 所以，`sizeof(P) = 4 + 4 = 8` 字节。

**虚函数表（vtable）**：当类中有虚函数时，编译器会生成一个虚函数表（vtable）来管理虚函数的动态绑定。

**虚函数表指针（vptr）**：每个对象都会有一个隐藏的指针 `vptr` 指向它所属类的虚函数表。这是实现动态多态的基础。

## 例题43

C++中下列说法正确的是( )

A.class中的constructor不可省略

B.constructor必须与class同名,方法也可以与class同名

C.constructor在一个对象被new时执行

D.一个class只能定义一个constructor

解答：

A ： class中的构造函数可以省略，编译器会自动添加一个默认

B ： 方法和类名相同会报错，提示 “构造函数不可以有返回值” 

C ： 构造函数在new时会执行，在声明一个对象时也会执行 

D ： 一个类可以有多个构造函数，构造函数可重载

### 知识点总结：

1. **Constructor（构造函数）**：
   - 构造函数是类的一种特殊成员函数，用于在创建对象时自动执行，初始化对象的成员变量。
2. **正确答案分析**：
   - **C. `constructor`在一个对象被`new`时执行**：正确。构造函数在使用`new`操作符动态创建对象时自动调用，进行初始化操作。
3. **选项错误解析**：
   - **A. `class`中的`constructor`不可省略**：错误。构造函数可以省略，若省略则编译器会自动提供一个默认的无参构造函数。
   - **B. `constructor`必须与`class`同名，方法也可以与`class`同名**：错误。构造函数必须与类名同名，但普通成员方法不能与类同名，否则编译器无法区分构造函数和普通方法。
   - **D. 一个`class`只能定义一个`constructor`**：错误。C++支持构造函数的重载，一个类可以定义多个构造函数，只要它们的参数列表不同。
4. **补充知识点**：
   - **构造函数重载**：C++允许一个类中有多个构造函数，通过不同的参数来实现构造函数的重载。
   - **默认构造函数**：当类中没有定义构造函数时，编译器会自动提供一个默认构造函数。
   - **析构函数**：类还可以定义一个析构函数，用于在对象的生命周期结束时执行清理操作，析构函数以`~`开头，并且不能被重载。

## 例题44

 哪些因素可能会影响到一个类的大小（多选）

A.成员个数

B.函数个数

C.是否有虚函数

D.虚函数个数

E.静态变量个数

F.对齐方式

解答：

这里A选项描述不够准确，个人觉得不选它是存在争议的，“成员个数”，成员应该包括：静态数据成员，非静态数据成员，静态成员函数，非静态成员函数。成员函数（包括静态和非静态）和静态数据成员都是不占存储空间的。 

**对象大小 = 虚函数指针 + 所有非静态数据成员大小 + 因对齐而多占的字节**

不论有多少个虚函数，都有一个指向虚函数表的指针，占用4字节（32位系统）。

### 知识点总结

1. **类的大小**：在 C++ 中，一个类的大小通常由其非静态成员的大小、虚函数的存在与否、对齐方式等因素决定。静态成员和成员函数本身不会直接影响类的大小。
2. **答案解析**：
   - **A. 成员个数**：正确。类的非静态成员变量的数量和类型会影响类的大小，因为每个非静态成员都占用类的内存空间。
   - **B. 函数个数**：错误。成员函数本身不会影响类的大小，因为函数存储在代码区，类对象中只包含函数指针，而不是函数本身。
   - **C. 是否有虚函数**：正确。如果类包含虚函数，编译器会为类添加一个虚函数表指针（vptr），因此会增加类的大小。
   - **D. 虚函数个数**：正确。虽然虚函数表指针（vptr）本身只占用一个指针大小，但如果虚函数很多，虚函数表的内存大小可能增大（vptr 指向虚表，不直接存在于对象中）。
   - **E. 静态变量个数**：错误。静态变量属于类而非对象本身，它们存储在全局静态区域，与类的对象大小无关。
   - **F. 对齐方式**：正确。编译器根据系统的对齐方式来存储类的成员变量，这会影响类的大小。比如，有些成员变量之间会有填充字节，以满足对齐要求。
3. **补充知识点**：
   - **虚函数表指针（vptr）**：当类包含虚函数时，每个对象中会包含一个指向虚函数表（vtable）的指针，该指针占用额外的空间。
   - **内存对齐**：不同的对齐方式会影响类的大小。编译器会插入填充字节（padding）以确保每个成员变量按对齐要求存储。
   - **成员变量排列顺序**：在某些情况下，调整成员变量的顺序可以减少填充字节，从而减少类的大小。

## 例题45

下列函数中，能声明为虚函数的是（）?

A.构造函数

B.公有成员函数

C.析构函数

D.私有成员函数

解答：

这是不能声明为虚函数的函数

> 1. 不能被继承的函数。      
> 2. 不能被重写的函数。     

  1）普通函数 

  普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。 

  而多态体现在运行时绑定。通常通过基类指针指向子类对象实现多态。 

  2）友元函数 

  友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。 

  3）构造函数 

  首先说下什么是构造函数，构造函数是用来初始化对象的。假如子类可以继承基类构造函数，那么子类对象的构造将使用基类的构造函数，而基类构造函数并不知道子类的有什么成员，显然是不符合语义的。从另外一个角度来讲，多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。因此构造函数不允许继承。 

  4）内联成员函数 

  我们需要知道内联函数就是为了在代码中直接展开，减少函数调用花费的代价。也就是说内联函数是在编译时展开的。而虚函数是为了实现多态，是在运行时绑定的。因此显然内联函数和多态的特性相违背。 

  5）静态成员函数 

  首先静态成员函数理论是可继承的。但是静态成员函数是编译时确定的，无法动态绑定，不支持多态，因此不能被重写，也就不能被声明为虚函数。

### 知识点总结

1. **虚函数**：虚函数是通过 `virtual` 关键字声明的成员函数，用于支持**动态多态性**，即在运行时决定调用的函数版本。通常虚函数用于基类中，以便派生类可以重写（override）它们，并在运行时实现多态行为。
2. **答案解析**：
   - **A. 构造函数**：错误。构造函数不能声明为虚函数。构造函数在对象创建时被调用，如果它是虚函数会造成逻辑冲突，因为在构造函数中，虚函数机制还没有完全建立。因此，构造函数不能是虚函数。
   - **B. 公有成员函数**：正确。任何公有成员函数都可以声明为虚函数。这样，派生类可以覆盖这些虚函数，以便基类指针或引用可以在运行时调用派生类版本。
   - **C. 析构函数**：正确。析构函数可以声明为虚函数，特别是在使用多态时，这非常重要。声明虚析构函数可以确保派生类对象通过基类指针删除时，正确调用派生类的析构函数，防止资源泄漏。
   - **D. 私有成员函数**：错误。虽然私有成员函数**理论上可以声明为虚函数**，但它们不能被外部访问，也无法通过基类指针调用，因此几乎没有实际意义。
3. **补充知识点**：
   - **虚析构函数的重要性**：在多态继承结构中，如果基类指针指向派生类对象并通过基类指针删除对象，基类的析构函数应声明为虚函数，确保派生类的析构函数也被正确调用。
   - **纯虚函数**：纯虚函数是虚函数的一种特殊形式，通常用于定义接口或抽象类，必须在派生类中实现。纯虚函数的声明形式为 `virtual void func() = 0;`。
   - **虚函数表（vtable）和虚函数指针（vptr）**：当一个类中包含虚函数时，编译器会为该类创建一个虚函数表（vtable），对象会存储一个指向虚表的指针（vptr），从而支持动态绑定和多态。

## 例题46

下列对派生类的描述中， _______________是错的。

A.一个派生类可以作另一派生类的基类

B.派生类至少有一个基类

C.派生类的成员除了它自己的成员外，还包含了它的基类的成员

D.派生类中继承的基类成员的访问权限到派生类中保持不变

解答：

应该是MAX吧。这是我在网上找的。 

1. public继承方式
        基类中所有 public 成员在派生类中为 public 属性；
        基类中所有 protected 成员在派生类中为 protected 属性；
        基类中所有 private 成员在派生类中不能使用。
2. protected继承方式
        基类中的所有 public 成员在派生类中为 protected 属性；
        基类中的所有 protected 成员在派生类中为 protected 属性；
        基类中的所有 private 成员在派生类中不能使用。
3. private继承方式
        基类中的所有 public 成员在派生类中均为 private 属性；
        基类中的所有 protected 成员在派生类中均为 private 属性；
        基类中的所有 private 成员在派生类中不能使用。

### **知识点总结：**

1. **派生类可以作为另一派生类的基类**
   - 即多层次继承是允许的，比如 `class C : public B {}`，其中 `B` 是 `A` 的派生类，这样 `C` 也会间接继承自 `A`。因此，**选项 A 是正确的**。
2. **派生类必须有至少一个基类**
   - 派生类就是从已有类派生出来的，因此至少要有一个基类。**选项 B 是正确的**。
3. **派生类包含了基类的成员**
   - 派生类不仅有自己的成员变量和成员函数，还继承了基类的成员。**选项 C 是正确的**。
4. **基类成员的访问权限不一定在派生类中保持不变**
   - 基类成员的访问权限在派生类中可能发生变化，具体取决于派生方式（public、protected、private 继承）。例如，通过 `public` 继承，基类的 `public` 和 `protected` 成员会分别成为派生类的 `public` 和 `protected` 成员，而 `private` 继承会将所有基类成员在派生类中转为 `private`。因此，**选项 D 是错误的**。

## 例题47

关于迭代器失效，下面说法错误的有?

A

当向vector容器插入（push_back）一个元素后，end操作返回的迭代器肯定失效

B

当向vector容器插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变,此时first和end操作返回的迭代器都会失效

C

当vector容器erase一个元素后，仅指向删除点的迭代器失效

D

在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效

E

对于节点式容器(map, list, set)元素的删除，插入操作会导致指向该元素的迭代器失效，其他元素迭代器不受影响

解答：

《C++Primer》第五版315页，如果删除deque的首（尾）元素，仅首（尾）迭代器失效，其他不受影响。

### **知识点总结：**

1. **向 `vector` 容器插入(push_back)一个元素后 `end` 操作返回的迭代器肯定失效**
   - 这是正确的。向 `vector` 容器添加元素会导致 `end` 迭代器指向的尾端位置变化，导致 `end` 迭代器失效。因此，**选项 A 是正确的**。
2. **向 `vector` 插入元素后，可能会引起 `capacity` 改变**
   - 当插入元素导致 `vector` 的 `capacity` 重新分配时，`begin` 和 `end` 返回的所有迭代器都会失效（因为会在内存中移动）。因此，**选项 B 是正确的**。
3. **当 `vector` 执行 `erase` 操作时，不仅仅是指向删除点的迭代器失效**
   - `vector` 中 `erase` 操作会使删除位置及其后的所有迭代器失效。**选项 C 是错误的**。
4. **在 `deque` 容器的任何位置插入或删除操作，通常会使所有迭代器失效**
   - `deque` 在插入或删除时，由于内存结构的复杂性，可能会导致所有迭代器失效，而不仅限于指向该位置的迭代器失效。**选项 D 是错误的**。
5. **节点式容器（如 `map`、`list`、`set`）的迭代器特性**
   - 对于节点式容器，插入和删除操作只会使指向修改元素的迭代器失效，而不影响其他元素的迭代器。**选项 E 是正确的**。

## 例题48

下列关于const和#define定义常量的区别，说法不正确的有（）

A.define宏是在预处理阶段展开。const常量是编译运行阶段使用

B.宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查

C.define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)

D.const定义和#define定义的常量在程序运行过程中只有一份拷贝

解答：

A，正确，#define定义的宏是在预处理阶段进行替换的，const常量是在编译、运行阶段进行使用的。 

注意是仅仅的字符串替换，并不会检查其合法性。 

预处理阶段做了的任务： 
 1:将头文件中的内容(源文件之外的文件)插入到源文件中 
 2:进行了宏替换的过程（简单的字符串替换），定义和替换了由#define指令定义的符号 
 3:删除掉注释的过程，注释是不会带入到编译阶段 
 4:条件编译

B，正确，所有的宏替换只是简单的字符串替换，注意是字符串替换，所以并不会检查其合法性，而const定义的常量依然是内置类型等，所以会对其进行类型安全检查。 

C，正确，宏定义在程序中使用了几次在预处理阶段就会被展开几次，并不会增加内存占用，但是宏定义每展开一次，代码的长度就要发生变化（所以有利必有弊啊！），而const常量也会为其分配内存（如果是动态申请空间肯定就是堆中了）。 

D，错误，const定义的常量只有一次拷贝没毛病，而define定义的变量在内存中并没有拷贝，因为所有的预处理指令都在预处理时进行了替换

### 知识点总结

1. **预处理阶段和编译阶段**：
   - `#define` 宏常量在**预处理阶段**展开，即在编译前直接替换为定义的值。
   - `const` 常量在**编译阶段**进行类型检查，属于编译运行时使用的常量。
2. **类型检查**：
   - `#define` 宏常量**没有具体类型**，只是简单的文本替换，不会进行类型检查。
   - `const` 常量具有明确的类型，在编译阶段会进行**类型检查**，确保类型安全。
3. **内存分配**：
   - `#define` 宏只是简单的文本替换，不会分配内存。
   - `const` 常量会在**内存中分配空间**，可以存储在栈区或全局内存区（堆）。
4. **拷贝次数**：
   - `const` 常量在程序运行时一般只有一份拷贝，因为编译器会优化存储和访问方式。
   - 但 **`#define` 并不是在程序运行时存储的数据**，而是文本展开，不具有“拷贝”的概念

## 例题49

某32位系统下, C++程序如下所示，sizeof 的值应为？

```c++
char str[] = "http://www.renren.com"  //（21个字符）
char *p = str ; 
```

请计算

```c++
sizeof (str ) = ？//（1）
sizeof (p) = ？//（2）
void Foo (char str[100]){
    sizeof(str) = ？//（3）
}
void *p = malloc(100);
sizeof(p) = ？//（4）
```

A.22, 22, 100, 100

B.4, 4, 4, 4

C.22, 4, 4, 4

D.22, 4, 100, 4

解答：
C 函数传递时数组退化为指针, 数组长度就是你定义数组时方括号中数字的大小。 字符串长度就是字符的个数。 字符串所占空间大小就是字符串长度+1（1个结束符的长度）； 作为函数的形参传递时数组退化为指针 char c[10]={'x','y','z'},d[]={'x','y','z'}; 不以‘\0’作为结束标志的，它就没有串结束标志， 字符数组的长度，就是数组的长度 sizeof(c)=10,sizeof(d)=3

### 知识点总结

1. **`sizeof`的用法**
   `sizeof` 是一个运算符，用于获取变量或类型在内存中的字节大小。具体来说，它可以用于数组、指针、数据类型等。
2. **字符串数组和指针的大小**
   - **数组大小**：`sizeof(str)` 返回数组的总大小。因为字符串 `"http://www.renren.com"` 有 21 个字符，加上字符串末尾的空字符 `\0`，所以 `sizeof(str)` 返回 **22**。
   - **指针大小**：在 32 位系统中，指针的大小固定为 **4 字节**，无论指向的数据类型是什么。
3. **函数参数的数组退化**
   - 在 `void Foo(char str[100])` 中，传递数组作为函数参数时，数组退化为指针。因此，`sizeof(str)` 实际上计算的是指针的大小，而不是数组的大小，所以返回 **4**。
4. **动态内存分配**
   - 在 `void *p = malloc(100);` 中，`p` 是一个 `void` 指针，指向分配的 100 字节的内存。但 `sizeof(p)` 只计算指针本身的大小，而不管它指向的内存大小。因此，在 32 位系统中，`sizeof(p)` 返回 **4**。

## 例题50

下面关于迭代器失效的描述哪个是错误的（）

A.vector的插入操作不会导致迭代器失效

B.map的插入操作不会导致迭代器失效

C.vector的删除操作只会导致指向被删除元素及后面的迭代器失效

D.map的删除操作只会导致指向被删除元素的迭代器失效

解答：

选A，因为由 Vector 的 iterator 和 listIterator 方法所返回的迭代器是快速失败的 ：如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。

### 知识点总结

- **vector** 的插入和删除操作可能导致迭代器失效，特别是内存重新分配或删除的元素位置影响其他元素时。
- **map** 的插入操作不会导致迭代器失效，删除操作只影响指向被删除元素的迭代器。

## 例题51

有关下面程序说法正确的是（）（注：└┘代表空格）

```c+
int main() { 
    char s[6]= "abcd";
    printf("\"%s\"\n", s);
    return 0;   
}
```

A.“abcd”

B.\"abcd\"

C."abcd└┘"

D.编译错误

解答：

因为像 " 这类的符号自己想想，是不是输不出来，所以要加一个 \ ，这个叫转义符号，" \" "这样子就能输出 " 了（第一个双引号和第三个双引号对应，输出第二个双引号）

### 知识点总结

1. **数组初始化**

- 字符串初始化：

  在 C 中，字符串字面量（如 "abcd"）会自动被添加一个 空字符（\0）来标识字符串的结束。因此，char s[6] = "abcd"; 实际上创建了一个 6 个字符的数组，其中前 5 个字符是 "abcd"，第 6 个字符是 \0，表示字符串的结束。

  - 数组的大小为 6，因为包括了空字符 `\0`，即 `char s[6] = "abcd"` 相当于 `{'a', 'b', 'c', 'd', '\0'}`。

2. **`printf` 中的格式化输出**

- **格式化字符串**：
  在 `printf` 中，`"%s"` 用于输出以空字符（`\0`）结尾的字符串。该格式符会输出数组或字符串常量中的所有字符，直到遇到第一个空字符 `\0` 为止。
  - 如果字符串 `"abcd"` 被传入 `printf`，它会输出 `abcd`，直到遇到结束标志 `\0`。
- **转义字符**：
  - **`\"`**：表示输出双引号字符。转义字符 `\"` 在 C 中表示双引号本身而不是字符串的边界。例如，`printf("\"abcd\"");` 会输出 `"abcd"`，其中 `\"` 表示输出双引号字符。
  - **`"\n"`**：表示换行字符，会将输出光标移到下一行。

## 例题52

在C++中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该（）

A

将构造函数设为私有

B

将析构函数设为私有

C

将构造函数和析构函数均设为私有

D

没有办法能做到

解答：

B [ 编 译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。 因此， 将析构函数设为私有，类对象就无法建立在栈（静态）上了，只能在堆上（动态new）分配类对象 。]

### 知识点总结

在 C++ 中，为了让某个类的对象只能通过 `new` 来创建，而不能直接创建实例（即禁止栈上创建对象），可以使用以下技术：

1. **构造函数的访问控制**

- 构造函数私有化：
  - 如果将构造函数设置为 **私有**，则不能在类外部直接调用它来创建对象。这意味着普通的栈分配对象将无法创建该类的实例。
  - `new` 的工作方式：
    - `new` 调用的是构造函数来动态分配内存并初始化对象。即使构造函数被设为私有，`new` 仍然能够通过类的内部机制创建对象，因为 `new` 是在类的作用域内进行的，它可以访问私有成员。
- 析构函数的访问控制：
  - 析构函数的作用是销毁对象并释放内存。将析构函数设为私有可以防止对象在外部被销毁，但这并不直接影响对象的创建。
  - 在一些场景下，如果析构函数是私有的，那么对象无法通过普通的方式 `delete`，只能由类的成员函数来销毁，通常是为了控制资源的释放。

2. **禁用栈上的对象创建**

- 通过将 **构造函数设为私有**，可以禁止直接创建类对象，但仍然可以使用 `new` 在堆上创建对象。这样可以确保对象只能通过 `new` 动态创建，而不能通过栈上创建。
- **防止栈上的对象创建**：这样做的目的通常是控制类的生命周期，强制对象的创建和销毁由堆上的 `new` 和 `delete` 来管理，而不是栈上的自动管理。

## 例题53

下列程序的运行结果是0.请为横线处选择合适的程序（）

```c++
#include <iostream>
#include <cmath>
using namespace std;
class Base {
public:
    Base(int X = 0);
    Base(Base &p);
    static void GetC(Base a1, Base a2) {
        cout << a2.X - a1.X;
    }
private:
    int X;
};
Base::Base(int XX) {
    X = XX;
}
Base::Base(Base &p) {
    X = p.X;
}
int main() {
    Base a1(5);
    Base a2(a1);
    __________ = Base::GetC;
    (*q)(a1, a2);
    return 0;
}
```

A.void (Base::*q)(Base,Base)

B.void *q(Base,Base)

C.void *q()

D.void (*q)(Base,Base)

解答：

**C++指向函数的指针定义方式为：** 

返回类型  (*指针名）  (函数参数列表)  ，例如 void （*p）（int）是指向一个返回值为void 参数为int类型的函数 

**对于指向成员函数的指针略有不同：** 

**1.指向非静态成员函数：** 

定义方式：返回类型 （类名::*指针名）（函数参数列表）例如void （A::*p）（int）是一个指向A类中成员函数的函数指针。  

赋值方式：p=&A::函数名，而一般的函数指针的赋值是p=函数名即可，注意区别。（成员函数必须是public类型的）  

调用方式：成员函数指针的调用必须通过类对象进行调用，a.*p(int)即可调用成员函数（该成员函数是public类型的）  

**1.静态成员函数**  

对于静态成员函数的定义和使用方法都与普通函数指针的相同，只是在赋值的时候和非静态成员们函数指针的赋值方法相同。  

因为静态成员函数的指针类型是与普通函数指针类型相同的。  

因此，选项A为指向非静态成员函数时的写法；B、C格式错误；D为指向静态成员函数时的写法 

### 知识点总结

**C++指向函数的指针定义方式为：** 

返回类型  (*指针名）  (函数参数列表)  ，例如 void （*p）（int）是指向一个返回值为void 参数为int类型的函数 

**对于指向成员函数的指针略有不同：** 

**1.指向非静态成员函数：** 

定义方式：返回类型 （类名::*指针名）（函数参数列表）例如void （A::*p）（int）是一个指向A类中成员函数的函数指针。  

赋值方式：p=&A::函数名，而一般的函数指针的赋值是p=函数名即可，注意区别。（成员函数必须是public类型的）  

调用方式：成员函数指针的调用必须通过类对象进行调用，a.*p(int)即可调用成员函数（该成员函数是public类型的）  

**1.静态成员函数**  

对于静态成员函数的定义和使用方法都与普通函数指针的相同，只是在赋值的时候和非静态成员们函数指针的赋值方法相同。  

因为静态成员函数的指针类型是与普通函数指针类型相同的。 

## 例题54

```c++
int main()
{
    char *p = "hello,world";
    return 0;
}
```

p和"hello,world"存储在内存哪个区域？

A.栈，堆

B.栈，栈

C.堆，只读存储区

D.栈，只读存储区

解答：

根据C语言中的特性和定义p是一个局部变量，而C语言中局部变量存在于栈中，"hello wrold"是一个字符串字面常量，因此存储于程序的只读存储区中，p在这里其实只是指向了"hello wrold"在只读存储区中的地址而已。

### 知识点总结：

1. **栈（Stack）**：

   - **定义**：栈是用于存储局部变量和函数调用时保存上下文的内存区域。

   - 特点

     ：

     - 局部变量通常存储在栈上。
     - 栈内存由操作系统自动分配和回收。
     - 栈的内存使用遵循先进后出的原则，栈内存的分配与回收非常快速。
     - 栈内存大小有限，过多的递归或过大的局部变量可能导致栈溢出。

2. **堆（Heap）**：

   - **定义**：堆是一个用于动态分配内存的区域，通常由程序员手动管理。

   - 特点

     ：

     - 在堆上分配的内存需要手动释放（通过 `new` 和 `delete` 或 `malloc` 和 `free` 等）。
     - 堆内存大小一般由操作系统限制。
     - 与栈不同，堆内存分配不遵循先进后出的规则，内存可以分散在堆中。

3. **只读存储区（Text Segment）**：

   - **定义**：只读存储区是程序代码段的一部分，通常用于存储常量数据（如字符串字面量、常量等）。

   - 特点

     ：

     - 常量字符串（如 `"hello,world"`）通常存储在只读存储区中。
     - 该区域的内容不能被修改，试图修改常量字符串会导致运行时错误。
     - 只读存储区是内存中的一个固定区域，通常由操作系统加载程序时进行分配。

4. **字符串字面量**：

   - **定义**：字符串字面量是程序中直接写出的字符串常量，例如 `"hello,world"`。

   - 存储位置

     ：

     - 字符串字面量在内存中是不可修改的，因此它们通常存储在 **只读存储区**。
     - 编译器为每个字符串字面量分配内存并将其放入只读存储区。

5. **局部变量与常量的区别**：

   - **局部变量**：存储在栈上，生命周期仅限于函数的调用期间。
   - **常量**：例如字符串字面量，通常存储在只读存储区，其值不可修改。

6. **内存区域总结**：

   - **栈**：存储局部变量和函数调用的上下文信息。
   - **堆**：存储动态分配的内存，需要手动管理。
   - **只读存储区**：存储程序中的常量数据，例如字符串字面量和常量。
   - **数据段和BSS段**：存储已初始化和未初始化的全局变量、静态变量。

## 例题55

对于代码段

```c++
int a[10];
```

问下面不可以表示a[1]地址的是（）

A

`&a[0] + 1`

B

`a + sizeof(int)`

C

`(int*)&a + 1`

D

`(int*)((char*)&a + sizeof(int))`

解答：

a+sizeof(int)，等价于a[4]的地址，因为数组a为int型，步长为4，+1就相当于向前进了4字节，等于a[1]地址，+4相当于进了16字节，等于a[4]地址

### 知识点总结：

1. **数组名的指针表现**：
   - 在 C++ 中，数组名 `a` 通常会自动转换为指向数组第一个元素的指针。因此，`a` 等价于 `&a[0]`，即 `int*` 类型的指针。
2. **指针偏移**：
   - 指针的偏移是按指针所指向的数据类型的大小进行的。
     - 例如，`a + 1` 会将指针 `a` 偏移到 `a[1]`，因为 `a` 是指向 `int` 类型的指针，所以偏移是按照 `sizeof(int)` 字节进行的。
   - 如果你有一个指针 `p`，表示数组元素或结构体，`p + 1` 实际上表示地址 `p` 向前偏移一个单位（即一个元素的大小）。
3. **强制类型转换问题**：
   - 强制转换指针时需要特别注意类型匹配，尤其是数组与单个元素之间的转换。不能将指向整个数组的指针直接转换为指向单个元素的指针，可能会导致错误的地址计算。
4. **按字节偏移**：
   - 字节偏移可以通过将指针转换为 `char*` 类型来进行，因为 `char` 类型的大小是 1 字节。通过这种方式，可以实现对地址的精确字节偏移.

## 例题56

有以下语句定义

```c++
int x =5;
const int * const p = &x;
const int &q=x; 
int const *next=&x;
const int *j=&x;
```

则有语法错误的是（）

A

\* p =1;

B

q++;

C

next++;

D

(*j)++;

解答：

  一句话搞定 const修饰指针变量： 

​      const在*的左边，则指针指向的变量的值，不可直接通过指针改变（可以通过其他途径改变）； 

​      在*的右边，则指针的指向不可变。 

​      简记为“左定值，右定向”。 

### 知识点总结：

1. **指针常量与常量指针**：
   - **`const int \*p` 或 `int const \*p`**：指向常量的指针，指针指向的数据不能修改，但指针本身可以改变，指向其他变量。
   - **`int \* const p` 或 `const int \* const p`**：常量指针，指针本身不可改变，但指向的数据可以修改（如果数据本身是可变的）。
   - **`const int \* const p`**：常量指针，既不可改变指向的地址，也不能修改指向的数据。
2. **常量引用**：
   - **`const int &q`**：常量引用，引用本身不能改变，且通过引用不能修改被引用的对象（即使是指向非 `const` 对象的引用）。常量引用通常用于确保数据在函数中不可修改。
3. **指针与引用的区别**：
   - 指针可以改变指向的位置，而引用绑定到一个对象后不能再改变指向。
   - 常量指针、常量引用的存在，目的就是避免不小心修改原数据。
4. **自增操作**：
   - 对于常量引用（`const int &q`），无法进行自增或修改操作。
   - 对于常量指针（`const int *p`），指向的内容不可修改，但指针本身可以修改指向的位置。
   - 对于常规指针（`int *next`），指向的内容可以修改，指针本身也可以修改指向。
